<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>时光收藏</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.hitime.wiki/"/>
  <updated>2019-11-04T06:17:39.325Z</updated>
  <id>https://blog.hitime.wiki/</id>
  
  <author>
    <name>zhangdp</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为什么要写单元测试</title>
    <link href="https://blog.hitime.wiki/2019/11/04/20191104-unit-test/"/>
    <id>https://blog.hitime.wiki/2019/11/04/20191104-unit-test/</id>
    <published>2019-11-04T05:50:32.000Z</published>
    <updated>2019-11-04T06:17:39.325Z</updated>
    
    <content type="html"><![CDATA[<h2 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类"></a>测试分类</h2><p>RAD（Rap Application Development，快速应用开发）模型是软件开发过程中的一个重要模型，由于其模型构图形似字母V，所以又称软件测试的V模型，V模型大体可以划分为以下几个不同的阶段步骤：需求分析、概要设计、详细设计、软件编码、单元测试、集成测试、系统测试、验收测试。</p><p><img src="/2019/11/04/20191104-unit-test/unit_test_1.png" alt="RAD"></p><p>通常研发在完成开发编码后都会进行自测，自测所包含的测试类型应当为单元测试和集成测试（联调和功能测试）。联调和功能测试大部分开发能很好的完成，因为这一部分是能够根据产品需求看得见摸得着的。往往单元测试就很容易被忽略。</p><h2 id="什么是单元测试"><a href="#什么是单元测试" class="headerlink" title="什么是单元测试"></a>什么是单元测试</h2><p>如果你听说过“测试驱动开发”（TDD：Test-Driven Development），单元测试就不陌生。<br>所谓测试驱动开发，是指先编写接口，紧接着编写测试。编写完测试后，我们才开始真正编写实现代码。在编写实现代码的过程中，一边写，一边测，什么时候测试全部通过了，那就表示编写的实现完成了：</p><p><img src="/2019/11/04/20191104-unit-test/unit_test_2.png" alt="TDD"></p><p>当然，这是一种理想情况。大部分情况是我们已经编写了实现代码，需要对已有的代码进行测试。<br>比如对函数abs()，我们可以编写出以下几个测试用例：</p><blockquote><ol><li>输入正数，比如1、1.2、0.99，期待返回值与输入相同；</li><li>输入负数，比如-1、-1.2、-0.99，期待返回值与输入相反；</li><li>输入0，期待返回0；</li><li>输入非数值类型，比如null，期待抛出类型错误异常。</li></ol></blockquote><p>把上面的测试用例放到一个测试模块里，就是一个完整的单元测试。<br>如果单元测试通过，说明我们测试的这个函数能够正常工作。如果单元测试不通过，要么函数有bug，要么测试条件输入不正确，总之，需要修复使单元测试能够通过。<br>单元测试通过后有什么意义呢？如果我们对abs()函数代码做了修改，只需要再跑一遍单元测试，如果通过，说明我们的修改不会对abs()函数原有的行为造成影响，如果测试不通过，说明我们的修改与原有行为不一致，要么修改代码，要么修改测试。<br>单元测试是开发人员自我测试的存续，一次我在做开发月供计算的时候，突然测试告知当月利率为0时月供计算异常。我分析问题后对利率为0的计算月供和本金做总贷金额/总期数和利息返回0处理，因为我更改了计算类我如何判断是否对之前逻辑有没有影响呢。这个时候我只需要将之前对该计算类的单元测试过一遍就能基本排除对之前没有影响，如下图：</p><p><img src="/2019/11/04/20191104-unit-test/unit_test_3.png" alt="Plan_test"></p><p>开始编写单元测试就意味着你摆脱了祈祷式编程走上了一条代码可控的光明之路。</p><h2 id="单元测试的特点"><a href="#单元测试的特点" class="headerlink" title="单元测试的特点"></a>单元测试的特点</h2><p>理想情况下，单元测试应该是相互独立、可自动化运行的。<br>正确的单元测试应当遵循以下特点：</p><table><thead><tr><th>资源</th><th>单元测试</th></tr></thead><tbody><tr><td>网络访问</td><td>否</td></tr><tr><td>数据库访问</td><td>否</td></tr><tr><td>访问文件</td><td>否</td></tr><tr><td>访问用户界面</td><td>否</td></tr><tr><td>使用外部服务</td><td>否</td></tr><tr><td>多线程</td><td>否</td></tr><tr><td>使用sleep语句</td><td>否</td></tr><tr><td>使用系统属性设置</td><td>否</td></tr><tr><td>运行时间限制（毫秒）</td><td>60</td></tr><tr><td>强制时间限制（分钟）</td><td>1</td></tr></tbody></table><h2 id="如何做单元测试"><a href="#如何做单元测试" class="headerlink" title="如何做单元测试"></a>如何做单元测试</h2><p>说了这么多单元测试的优点，道理大家一定都懂，问题是如何做单元测试？</p><h3 id="简单类测试-还不是手到擒来"><a href="#简单类测试-还不是手到擒来" class="headerlink" title="简单类测试-还不是手到擒来"></a>简单类测试-还不是手到擒来</h3><p>简单类测试可以通过new一个类的方式进行测试，这样就保证后期部署时单元测试可以开启验证代码快速的验证代码的正确性（使用Spring容器服务的话启动非常慢）。</p><p><img src="/2019/11/04/20191104-unit-test/unit_test_4.png" alt="简单类测试"></p><h3 id="嵌套类测试-你得听我的"><a href="#嵌套类测试-你得听我的" class="headerlink" title="嵌套类测试-你得听我的"></a>嵌套类测试-你得听我的</h3><p>在日常开发中不可能只有一个简单类，更多的是需要借助Spring容器注入其他类进行使用，这个时候我们可以使用Mockito进行服务的注入和模拟。<br>我们先看一个简单的例子：<br>NestedBusinessService：</p><p><img src="/2019/11/04/20191104-unit-test/unit_test_5.png" alt="NestedBusinessService"></p><p>NestedBusinessService下使用了OrderManager做数据获取，我们希望测试NestedBusinessService中process方法的相关逻辑，我们不想关心OrderManager是如何获取数据的（也就是不再下探OrderManager类），测试内容如下：</p><p><img src="/2019/11/04/20191104-unit-test/unit_test_6.png" alt="NestedBusinessService"></p><p>这个时候我们可以使用Mockito中的mock方法将OrderManager类直接模拟出来，当碰到OrderManager类的方法时会自动返回null。有同学一定会说，这不行啊，返回null我怎么往下测试啊！<br>实际上你完全可以告诉被Mockito模拟的类运行到某个方式时你期望它返回什么，要达到这个目的我们可以使用Mockito的when方法，告诉它你期望执行的方法以及返回值。如下图：<br>NestedBusinessServiceTests：</p><p><img src="/2019/11/04/20191104-unit-test/unit_test_7.png" alt="NestedBusinessServiceTests"></p><p>我们可以看到在类的最前面我们申明了orderManager的全局变量，在@Before注解的方法中我们使用Mockito的mock方法模拟了一个OrderManager对象并赋给了orderManager。<br>在测试代码中49行我们通过when(Mockito.when()的静态方法形式)告知了Mockito我们希望运行到orderManager对象中loadByOrderId方法时返回一个预先设置好的Order对象。<br>这样我们就能完成一个嵌套类的测试工作了。</p><h3 id="多层嵌套类-我们该如何是好"><a href="#多层嵌套类-我们该如何是好" class="headerlink" title="多层嵌套类-我们该如何是好"></a>多层嵌套类-我们该如何是好</h3><p>刚讲了单层的嵌套类，如果碰到多层嵌套类，我们要同时测试Service层和Manager层该怎么办呢？是不是不做什么就能测试Manager层代码呢？上面我们讲了Mockito的mock方法会模拟一个对象，但是这个对象碰到方法的时候只会返回null，除非你告诉它返回什么，感觉傻傻的。我们现在介绍另外一个方法spy方法。spy方法也是模拟一个对象，但是这个对象是建立在真实类的基础上的，就好像Spring注入的类一样什么都能干。<br>如下图：<br>MultiLayerNestedBusinessServiceTests：</p><p><img src="/2019/11/04/20191104-unit-test/unit_test_8.png" alt="MultiLayerNestedBusinessServiceTests"></p><p>不是说什么都能干吗？怎么报错？是的，OrderManager类是一个真真实实的类，但是它毕竟没有将代码中所有的类都加载进来，这就导致OrderManager里的嵌套类自然就GG了。我们尝试将OrderMapper类也模拟出来，还是NullPorinter，如下图：</p><p><img src="/2019/11/04/20191104-unit-test/unit_test_9.png" alt="MultiLayerNestedBusinessServiceTests"></p><p>虽然我们将OrderMapper类也模拟出来了，但是orderManager对象已经是一个真实的对象了，在它初始化的时候已经加载了一个为null的OrderMapper对象，所以我们需要在orderManager对象初始化后注入一个已经模拟好的OrderMapper，如下图：</p><p><img src="/2019/11/04/20191104-unit-test/unit_test_10.png" alt="MultiLayerNestedBusinessServiceTests"></p><p>此时既然orderMapper也是模拟的也就需要告诉它什么方法应返回什么，如下图：</p><p><img src="/2019/11/04/20191104-unit-test/unit_test_11.png" alt="MultiLayerNestedBusinessServiceTests"></p><h3 id="静态类-没有最强只有更强"><a href="#静态类-没有最强只有更强" class="headerlink" title="静态类-没有最强只有更强"></a>静态类-没有最强只有更强</h3><p>日常代码中总会用到Util类，这些类的方法都是静态的，我们如何的完美的绕过它们呢？PowerMock是不二之选，如下图：<br>ImplLoadServiceTests：</p><p><img src="/2019/11/04/20191104-unit-test/unit_test_12.png" alt="ImplLoadServiceTests"></p><p>按照代码逻辑计算类型传相减的话得到的结果应该是-1，但是因为我们使用PowerMock替换了getBean的返回得到了相加的结果。<br>PowerMock可以实现完成对private//static//final方法的Mock，就不一一列举， 反正是没有最强只有更强。</p><h3 id="入参校验-请再爱我一次"><a href="#入参校验-请再爱我一次" class="headerlink" title="入参校验-请再爱我一次"></a>入参校验-请再爱我一次</h3><p>看到标题可能会有同学说，入参有什么好校验的，入参都是我传入的啊？非也非也，当我们要请求外部接口的时候，入参肯定是要做相应适配，如何验证入参的正确性呢，请听我从头到来。<br>如下图：</p><p><img src="/2019/11/04/20191104-unit-test/unit_test_13.png" alt="RpcBusinessService"></p><p>RpcBusinessService通过FinFeignClient请求远程服务得到用户信息并进行包装，上面的类大概就写了这些。在请求前因为用户类型和远程服务不匹配做了一次转换，我们希望在请求前进行一次请求入参校验避免转换出错。具体代码如下：</p><p><img src="/2019/11/04/20191104-unit-test/unit_test_14.png" alt="RpcBusinessServiceTests"></p><p>此处通过verify方法使用ArgumentCaptor在请求前进行了入参的捕获，我们用断言判断入参是否是预期的就能够很好的检验入参的正确性了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此单元测试相关内容就讲完了，至于如何实践还需要大家多在项目中摸索。单元测试看似是测试工作，但是对我们开发工作的延续，做的好的单元测试能够很有效的保障我们开发的功能是我们所预期的。希望大家能够重视单元测试避免祈祷式编程。</p><p>常用组件：</p><ol><li>Mockito</li><li>PowerMock</li><li>hamcrest</li></ol><p>示例代码：</p><ol><li><a href="https://gitee.com/hitime-wiki/demo-test" target="_blank" rel="noopener">demo-test: 单元测试实例程序</a></li></ol><p>参考文档：</p><blockquote><p><a href="https://www.cnblogs.com/findyou/p/6480411.html" target="_blank" rel="noopener">软件测试概念及分类整理汇总 - Findyou - 博客园</a><br><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017604210683936" target="_blank" rel="noopener">单元测试 - 廖雪峰的官方网站</a></p></blockquote><p>#博客</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;测试分类&quot;&gt;&lt;a href=&quot;#测试分类&quot; class=&quot;headerlink&quot; title=&quot;测试分类&quot;&gt;&lt;/a&gt;测试分类&lt;/h2&gt;&lt;p&gt;RAD（Rap Application Development，快速应用开发）模型是软件开发过程中的一个重要模型，由于其模型
      
    
    </summary>
    
    
      <category term="单元测试" scheme="https://blog.hitime.wiki/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>什么是编码</title>
    <link href="https://blog.hitime.wiki/2019/08/20/20190820-encode/"/>
    <id>https://blog.hitime.wiki/2019/08/20/20190820-encode/</id>
    <published>2019-08-20T11:37:27.000Z</published>
    <updated>2019-08-20T11:53:20.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是编码"><a href="#什么是编码" class="headerlink" title="什么是编码"></a>什么是编码</h2><p>编码是信息从一种形式或格式转换为另一种形式的过程，简单来讲就是语言的翻译过程。我们都知道计算机使用的是机器语言即二进制码，相信大部分人都无法流畅的阅读二进制码，于是为了能够让人类更好的理解计算机输出的结果就需要将机器语言转换为自然语言，比如英语、俄语和中文等。<br>这看似简单的语言转换过程随着计算机的普及与互联网化对语言字符的编码冲击也越来越大，编码规范的调整也伴随着整个计算机发展历史。</p><h2 id="现代编码模型"><a href="#现代编码模型" class="headerlink" title="现代编码模型"></a>现代编码模型</h2><p>为了能够更精确的描述在编码过程中各个产物的归属以便正确的描述产物所发挥的功能，于是多事之人将现代的编码整理为一套可以说明的模型而且分为五层之多。</p><p><strong>现代编码模型之分层：</strong></p><ol><li><strong>抽象字符表</strong>（ACR:Abstract character repertoire）：是一个系统支持的所有抽象字符的集合，简单来说就是该层规范要确定一个系统能够包含的字符和字符形式，比如Windows支持中文，那么它的抽象字符表一定有中文字符集合而且也适配不同编码方式指定具体是何字符。</li><li><strong>编码字符集</strong>（CCS:Coded Character Set）：是将字符集中每个字符映射到1个坐标（整数值对：x, y）或者表示为1个非负整数。字符集及码位映射称为编码字符集。例如，在一个给定的字符表中，表示大写拉丁字母“A”的字符被赋予整数65、字符“B”是66，如此继续下去。简单来说这就是一个映射关系表，将一串码值映射到抽象字符表里的特定字符。</li><li><strong>字符编码表</strong>（CEF:Character Encoding Form）：该层也称为”storage format”，对于一个包含几乎全球语言的字符集，比如Unicode字符集最多可以2的31次方个字符，用4个字节来存储一个，但是真的有必要在时时刻刻都使用4个字节来记录一个字符吗？很显然不是这样，比如拉丁字母“A”实际上需要二进制码<strong>01000001</strong>一个字节就可以表示，于是需要一种类似于压缩方式的方法来尽量用最少空间存储不同种类字符的方式比如后面会提到的UTF。所以这一层主要是描述字符编码所能采用的编码格式。</li><li><strong>字符编码方案</strong>（CES:Character Encoding Scheme）：也称作”serialization format”，将定长的整型值（即码元）映射到8位字节序列，以便编码后的数据的文件存储或网络传输。</li><li><strong>传输编码语法</strong>（transfer encoding syntax）：1. 用于处理上一层次的字符编码方案提供的字节序列。一般其功能包括两种：一是把字节序列的值映射到一套更受限制的值域内，以满足传输环境的限制，例如Email传输时 Base64或者quoted-printable，都是把8位的字节编码为7位长的数据；另一是压缩字节序列的值，如 LZW 或者 行程长度编码等无损压缩技术。</li></ol><h2 id="常用的编码"><a href="#常用的编码" class="headerlink" title="常用的编码"></a>常用的编码</h2><h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p><strong>ASCII</strong>（发音： [/ˈæski/]) ，<strong>A</strong>merican <strong>S</strong>tandard <strong>C</strong>ode for <strong>I</strong>nformation <strong>I</strong>nterchange，<strong>美国信息交换标准代码</strong>）是基于 拉丁字母的一套 计算机 编码系统。它主要用于显示 现代英语 ，而其扩展版本 EASCII 则可以部分支持其他 西欧 语言，并等同于国际标准ISO/IEC 646]。<br>ASCII编码由1个字节8bit来标识字符编码表映射关系，如果按字节来算最多支持256个字符映射，但是由于最高位始终为0，支持的字符更少了。下图为编码表：<br><img src="/2019/08/20/20190820-encode/encode-1.png" alt="ASCII码表"></p><p>从图中可以看到，如果使用ASCII码表，将二进制高四位（0100）低四位 （0001）对应ASCII码表就得到了A字符，如果要得到I LOVE Y，计算机只需要得到二级制01001001（I）00100000（空格）01001100（L）01001111（O）01010110（V）01000101（E）00100000（空格）01011001（Y）。<br>ASCII码所对应的所有字符高四位首位都为0，所以ASCII码成功的用7个比特位就完成了计算机语言转换为自然语言（人类语言）的壮举，这看起来很令人振奋，一如美国人天真的以为IPv4的最大数就能255.255.255.255（32位）总计4,294,967,296个地址（其中还有些专用地址占去一小部分）就能覆盖全球的网络设备。所以说当其他国家的语言比如中文、日文和阿拉伯文需要用计算机显示的时候就完全无法使用ASCII码如此少量的编码映射方式。</p><h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><p>1974年8月，中国开始了748工程，包括了用计算机来处理中文字，展开了各种研究工作，后来到1980年公布了 GB 2312-80汉字编码的国家标准。<br>GB 2312标准共收录6763个汉字 ，其中 一级汉字3755个， 二级汉字3008个；同时收录了包括 拉丁字母、 希腊字母、 日文、平假名及片假名字母、 俄语在内的682个字符。<br>看起来GB2312已经很牛逼了，使用2个字节作为编码字符集的空间，但是6763个汉字是真的不够用啊。</p><h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h3><p>我汉语博大精深，只有6763个字怎么够？于是GBK中在保证不和GB2312、ASCII冲突（即兼容GB2312和ASCII）的前提下，也用每个字占据2字节的方式又编码了许多汉字。经过GBK编码后，可以表示的汉字达到了20902个，另有984个汉语标点符号、部首等。值得注意的是这20902个汉字还包含了繁体字。</p><h3 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h3><p>然而，GBK的两万多字也已经无法满足我们的需求了，还有更多可能你自己从来没见过的汉字需要编码。这时候显然只用2字节表示一个字已经不够用了（2字节最多只有65536种组合，然而为了和ASCII兼容，最高位不能为0就已经直接淘汰了一半的组合，只剩下3万多种组合无法满足全部汉字要求）。因此GB18030多出来的汉字使用4字节编码。当然，为了兼容GBK，这个四字节的前两位显然不能与GBK冲突（实操中发现后两位也并没有和GBK冲突）。我国在2000年和2005年分别颁布的两次GB18030编码，其中2005年的是在2000年基础上进一步补充。至此，GB18030编码的中文文件已经有七万多个汉字了，甚至包含了少数民族文字。</p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>在ASCII编码明显不够用后美国国家标准学会又搞了几套ISO的编码规范来兼容其他中欧等国家的语言，但是兼容性还是有不少问题。最终美国加州的Unicode组织他们放大招搞了<em>Unicode</em>（万国码）打算借此一统江湖，最早Unicode也是最高16位2字节来进行映射，经过几番修改最终可以以最长32位4字节的空间来映射最多2的31次方个字符。看起来一切完美了，当然如果以后有了星际旅行并不一定能够完全标识全宇宙的文字。</p><p>从上面这一大堆改动来看，不管中国还是美国，在处理位数上远远低估了后续可能产生的扩展性，你可能会觉得一早就用4个字节来标识全球所有字符就完事了费那么大劲来回改。给你看一幅图你或许就会明白为什么那时候的科学家那么谨小慎微了。如图：<br>￼￼￼<br><img src="/2019/08/20/20190820-encode/encode-2.png" alt="IBM硬盘"></p><p><em>1956年IBM的硬盘，可存储5MB的数据</em></p><h2 id="UTF-8又是什么"><a href="#UTF-8又是什么" class="headerlink" title="UTF-8又是什么"></a>UTF-8又是什么</h2><p>Unicode确实是一套能够满足全球使用的字符集，但是难道真的需要每一个字符都占用4个字节吗？虽然现在的存储空间已经足够大了，但是4个字节一个字符的方式还是很不明智的，比如字符“A”二进制码<strong>01000001</strong>却需要以<strong>00000000000000000000000001000001</strong>的方式存储。这一定不是我们想要的。于是UTF（Unicode/UCS Transformation Format）应运而生，UTF是 字符编码五层次模型的第三层，通过特定的规则对Unicode字符编码进行一定的压缩和转换以便快捷传输。<br>UTF的代表就是UTF-16和UTF-8，千万不要以为UTF-16比UTF-8更厉害能够容纳更多字符，字符容纳数量都是是Unicode编码集所确定的范围，UTF只是通过不同的转换形式更快更高效的找到特定字符。而UFT-16 比较奇葩，它使用 2 个或者 4 个字节来存储。<br>对于 Unicode 编号范围在 0 ~ FFFF 之间的字符，UTF-16 使用两个字节存储，并且直接存储 Unicode 编号，不用进行编码转换，这跟 UTF-32 非常类似。<br>对于 Unicode 编号范围在 10000~10FFFF 之间的字符，UTF-16 使用四个字节存储，具体来说就是：将字符编号的所有比特位分成两部分，较高的一些比特位用一个值介于 D800~DBFF 之间的双字节存储，较低的一些比特位（剩下的比特位）用一个值介于 DC00~DFFF 之间的双字节存储。</p><p><strong>设计UTF-8编码表达方式的理由：</strong></p><ol><li>单字节字符的最高有效比特永远是0（大家可以看看其他编码方式如何别扭的兼容ASCII码的）；</li><li>多字节序列中的首个字符组的几个最高有效比特决定了序列的长度。最高有效位为<strong>110</strong>的是2字节序列，而<strong>1110</strong>的是三字节序列，如此类推；</li><li>多字节序列中其余的字节中的首两个最高有效比特为<strong>10</strong>。</li></ol><p><strong>转换关系如下图：</strong><br><img src="/2019/08/20/20190820-encode/encode-3.png" alt="UTF-8转换关系"></p><p>这样我们根据所要兼容的语言不同根据UTF-8多字节最高有效比特去判断编码最终使用了多少个字节来存储，其余的字节也都满足最高有效比特为10的特点有了一定的纠错功能。<br>简单一些理解就是UTF-16就是通过2个字节16位来控制压缩比例，而UTF-8已经以高精度的1个字节8位来控制压缩比例了。当然还有中UTF-32就可想而知，基本跟Unicode如出一辙。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是编码&quot;&gt;&lt;a href=&quot;#什么是编码&quot; class=&quot;headerlink&quot; title=&quot;什么是编码&quot;&gt;&lt;/a&gt;什么是编码&lt;/h2&gt;&lt;p&gt;编码是信息从一种形式或格式转换为另一种形式的过程，简单来讲就是语言的翻译过程。我们都知道计算机使用的是机器语言即二进
      
    
    </summary>
    
    
      <category term="编码" scheme="https://blog.hitime.wiki/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Flyway的部署</title>
    <link href="https://blog.hitime.wiki/2019/07/05/20190705-flyway/"/>
    <id>https://blog.hitime.wiki/2019/07/05/20190705-flyway/</id>
    <published>2019-07-05T03:46:05.000Z</published>
    <updated>2019-07-05T03:50:59.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Flyway官网的介绍是</p><blockquote><p>数据库的版本控制。<br>跨所有环境的强大架构演变。<br>轻松，愉快和简单的SQL。</p></blockquote><p>三句言简意赅的话如同Flyway本身一样犀利，通过Flyway我们可以轻松简单的对我们系统所使用的数据库进行跨环境版本控制。于是再也不会出现测试2和测试1的表结构不一样的问题了！<br><img src="/2019/07/05/20190705-flyway/flyway_1.png" alt="Flyway"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>集成Flyway插件<br>以Maven举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.flywaydb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flyway-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>初始化版本</p><ol><li>在 resource 文件夹下增加 db/migraton</li><li>在 migraton 目录添加基础SQL版本文件：V1__Base_version.sql<br>版本命名规则参见： <a href="https://flywaydb.org/getstarted/how" target="_blank" rel="noopener">https://flywaydb.org/getstarted/how</a><br>主要为V[版本]__[版本名称（以单下划线分隔单词）].sql</li><li>运行<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn flyway:baseline -Dflyway.url=[数据库地址] -Dflyway.user=[数据库用户名] -Dflyway.password=[数据库密码]</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>此时对应数据库会出现 flyway_schema_history 表，表中记录了初始化版本 &lt;&lt; Flyway Baseline &gt;&gt; 信息</p><ol start="3"><li>配置执行命令<br>为了每次部署都可以将变更的 SQL 同步到指定环境，我们将 Flyway 执行命令配置到自动部署工具，如下：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn flyway:migrate -Dflyway.url=[数据库地址] -Dflyway.user=[数据库用户名] -Dflyway.password=[数据库密码]</span><br></pre></td></tr></table></figure></li></ol><p>这样，Flyway 就配置好了，每次部署都会去resource//db/migraton目录下查找最新的变更记录和数据库中 flyway_schema_history 表记录的变更记录进行比较然后执行有变更的脚本保持结构一致。</p><p>更多信息参考：<a href="https://flywaydb.org" target="_blank" rel="noopener">Flyway by Boxfuse • Database Migrations Made Easy.</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Flyway官网的介绍是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数据库的版本控制。&lt;br&gt;跨所有环境的强大架构演变。&lt;br&gt;轻松，愉快和简
      
    
    </summary>
    
    
      <category term="Flyway" scheme="https://blog.hitime.wiki/tags/Flyway/"/>
    
  </entry>
  
  <entry>
    <title>工具收集</title>
    <link href="https://blog.hitime.wiki/2019/05/10/tools/"/>
    <id>https://blog.hitime.wiki/2019/05/10/tools/</id>
    <published>2019-05-10T09:09:28.000Z</published>
    <updated>2019-05-10T09:53:06.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="部署工具"><a href="#部署工具" class="headerlink" title="部署工具"></a>部署工具</h2><blockquote><p>Travis CI(在线部署工具)</p></blockquote><h2 id="博客系统"><a href="#博客系统" class="headerlink" title="博客系统"></a>博客系统</h2><blockquote><p>Hexo（支持GitHub Pages的Markdown博客系统）</p></blockquote><h2 id="代办工具"><a href="#代办工具" class="headerlink" title="代办工具"></a>代办工具</h2><blockquote><p>Things3(轻量级代办管理工具)<br>OmniFocus(重量级代办管理工具)  </p></blockquote><h2 id="代码质量工具"><a href="#代码质量工具" class="headerlink" title="代码质量工具"></a>代码质量工具</h2><blockquote><p>SonarQube<br>JaCoCo</p></blockquote><h2 id="项目管理工具"><a href="#项目管理工具" class="headerlink" title="项目管理工具"></a>项目管理工具</h2><blockquote><p>Confluence（文档管理）<br>Jira（开发流程管理）  </p></blockquote><h2 id="堡垒机"><a href="#堡垒机" class="headerlink" title="堡垒机"></a>堡垒机</h2><blockquote><p>JumpServer</p></blockquote><h2 id="SQL审核平台"><a href="#SQL审核平台" class="headerlink" title="SQL审核平台"></a>SQL审核平台</h2><blockquote><p>Yearning  </p></blockquote><h2 id="接口管理工具"><a href="#接口管理工具" class="headerlink" title="接口管理工具"></a>接口管理工具</h2><blockquote><p>Eolinker(分开源版和商业版，公司内部可以部署开源版，外部对接可以注册商业版)<br>Swagger(老牌接口管理系统，支持接口文档生成)<br>Postman(单机接口管理测试软件)  </p></blockquote><h2 id="编辑工具"><a href="#编辑工具" class="headerlink" title="编辑工具"></a>编辑工具</h2><blockquote><p>Visual Studio Code(和IDEA风格非常像，功能直接强大，插件丰富)  </p></blockquote><h2 id="作图工具"><a href="#作图工具" class="headerlink" title="作图工具"></a>作图工具</h2><blockquote><p>OmniGraffle(完美支持Mac的整套打包方案)<br>EdrawMax(亿图，支持非常多种类作图工具，收费，单机)<br>ProcessOn(在线作图工具，图形简单)  </p></blockquote><h2 id="数据库工具"><a href="#数据库工具" class="headerlink" title="数据库工具"></a>数据库工具</h2><blockquote><p>Navicat<br>DataGrip(Jetbrains公司出品，擅长于SQL纠错、格式化和事务管理等)<br>PowerDesigner(SyBase公司出品，老牌数据库设计工具，没有Mac版，上世纪设计体验)<br>Pdman(Mac上PowerDesigner替代品，基于Node.js的开源项目)  </p></blockquote><h2 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h2><blockquote><p>工具集：<a href="https://tool.lu/" target="_blank" rel="noopener">https://tool.lu/</a><br>Eolinker工具集：<a href="http://tool.eolinker.com/" target="_blank" rel="noopener">http://tool.eolinker.com/</a><br>ASCII艺术字：<a href="http://patorjk.com/software/taag/" target="_blank" rel="noopener">http://patorjk.com/software/taag/</a><br>Redis命令：<a href="http://doc.redisfans.com/" target="_blank" rel="noopener">http://doc.redisfans.com/</a><br>在线Markdown：<a href="https://stackedit.io/app#" target="_blank" rel="noopener">https://stackedit.io/app#</a><br>yml和properties转换：<a href="https://www.toyaml.com/index.html" target="_blank" rel="noopener">https://www.toyaml.com/index.html</a><br>算法面试题库：<a href="https://leetcode.com/" target="_blank" rel="noopener">https://leetcode.com/</a><br>国外SSD服务器：<a href="https://www.linode.com/（支持日本节点）" target="_blank" rel="noopener">https://www.linode.com/（支持日本节点）</a><br>Groovy在线文档：<a href="http://groovy-lang.org/gdk.html" target="_blank" rel="noopener">http://groovy-lang.org/gdk.html</a>  </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;部署工具&quot;&gt;&lt;a href=&quot;#部署工具&quot; class=&quot;headerlink&quot; title=&quot;部署工具&quot;&gt;&lt;/a&gt;部署工具&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Travis CI(在线部署工具)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;博客系统&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>反射性能比较</title>
    <link href="https://blog.hitime.wiki/2019/05/03/reflect-profiler/"/>
    <id>https://blog.hitime.wiki/2019/05/03/reflect-profiler/</id>
    <published>2019-05-03T08:39:13.000Z</published>
    <updated>2019-05-03T09:35:01.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近做央行征信项目在最初的一版设计尝试使用反射来进行方法调用，于是又”深入”的了解下反射的性能。<br>一开始看到网上的文章一篇看起来比较专业的性能对比测试，测试结果如下：<br><img src="/2019/05/03/reflect-profiler/reflect_profiler_1.jpg" alt="网上反射性能对比"><br>从图中可以看到，在最后一行ReflectAsm可谓是性能出众，一骑绝尘让其他反射方式难以望其项背。<br>周末有时间刚好想自己也对反射进行一个性能比较，顺便看看ReflectAsm如此出众是如何做到的，于是噩梦开始。</p><h2 id="第一步-写个像模像样的测试代码"><a href="#第一步-写个像模像样的测试代码" class="headerlink" title="第一步 写个像模像样的测试代码"></a>第一步 写个像模像样的测试代码</h2><blockquote><p>实验机器：<br>    MacBook Pro (Retina, 13-inch, Early 2015)<br>    处理器 2.9 GHz Intel Core i5<br>    内存 8 GB 1867 MHz DDR3<br>实验环境：<br>    java version “1.8.0_101”<br>    Java(TM) SE Runtime Environment (build 1.8.0_101-b13)<br>    Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)<br>ReflectAsm版本：1.11.9  </p></blockquote><p>本实验不重复实例化对象，只做方法调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> count = <span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line">        CalculateTest calculateTest = <span class="keyword">new</span> CalculateTest();</span><br><span class="line">        Class&lt;?&gt; c = Class.forName(<span class="string">"wiki.hitime.demo.service.CalculateTest"</span>);</span><br><span class="line">        Class&lt;?&gt;[] params = <span class="keyword">new</span> Class[<span class="number">1</span>];</span><br><span class="line">        params[<span class="number">0</span>] = Integer.class;</span><br><span class="line">        Method setNumMethod = c.getMethod(<span class="string">"setNum"</span>, params);</span><br><span class="line">        MethodAccess methodAccess = MethodAccess.get(c);</span><br><span class="line">        <span class="keyword">int</span> index = methodAccess.getIndex(<span class="string">"setNum"</span>);</span><br><span class="line"></span><br><span class="line">        Profiler profiler = <span class="keyword">new</span> Profiler(<span class="string">"Reflection count="</span> + count);</span><br><span class="line"></span><br><span class="line">        profiler.start(<span class="string">"直接调用"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            calculateTest.setNum(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        profiler.start(<span class="string">"标准反射"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            setNumMethod.invoke(calculateTest, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        profiler.start(<span class="string">"ReflectAsm反射"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            methodAccess.invoke(calculateTest, index, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        profiler.start(<span class="string">"ReflectionUtils反射"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            ReflectionUtils.invokeMethod(setNumMethod, calculateTest, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        profiler.stop();</span><br><span class="line">        profiler.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="第二步-拿到测试结果大肆夸赞ReflectAsm"><a href="#第二步-拿到测试结果大肆夸赞ReflectAsm" class="headerlink" title="第二步 拿到测试结果大肆夸赞ReflectAsm"></a>第二步 拿到测试结果大肆夸赞ReflectAsm</h2><p>这一步很重要，一定要拿到一个差距悬殊的结果，为后期夸赞ReflectAsm做好铺垫。原本计划是”运行”一点，图片到手，结论就有。哪知结果跌掉眼镜，如图：<br><img src="/2019/05/03/reflect-profiler/reflect_profiler_2.jpg" alt="跌掉眼镜的结果"><br>总体来看ReflectAsm确实性能出色，执行10亿次耗时3.759秒值得表扬，可是反射什么时候比直接调用还要快，难道在我埋头业务这几年”大清亡了”？ReflectAsm快我们假设是后起之秀，但是这些反射没有一个比直接调用慢的，这是为何？<br>在我思考良久排除了代码问题，得出一个结论”先出场的死得早”，于是我调换了执行顺序，如下图：<br><img src="/2019/05/03/reflect-profiler/reflect_profiler_3.jpg" alt="ReflectAsm先出场"><br><img src="/2019/05/03/reflect-profiler/reflect_profiler_4.jpg" alt="标准反射先出场"><br>从上两图可以看出，确实是先出场的都是配角，总体来看先执行的循环因为”宇宙射线”、”太阳黑子”和”黑洞引力”等不可抗拒原因跑的非常慢，至于为何会慢需要后面再来调查，毕竟本文是做反射性能对比的。<br>于是我为了保证基础环境一致进行了分次运行的方式来进行性能统计，结果如下图：<br><img src="/2019/05/03/reflect-profiler/reflect_profiler_5.jpg" alt="直接调用"><br><img src="/2019/05/03/reflect-profiler/reflect_profiler_6.jpg" alt="标准反射"><br><img src="/2019/05/03/reflect-profiler/reflect_profiler_7.jpg" alt="ReflectAsm"><br><img src="/2019/05/03/reflect-profiler/reflect_profiler_8.jpg" alt="ReflectionUtils"><br>从总体结果来看，耗时为：标准反射&gt;ReflectionUtils&gt;ReflectAsm&gt;直接调用，但是这样的结果已经并不重要了，总体大家的性能相差无几并没有网上科普文讲的差距悬殊。</p><h2 id="第三步-结论"><a href="#第三步-结论" class="headerlink" title="第三步 结论"></a>第三步 结论</h2><p>从整体实验过程来看，实验手法有时候决定结果的好坏，如果一开始我将直接调用放在最后，我可能已经得到一个看起来”公正”的结论。<br>从这次实验结论来看，做对比的过程才是实验精髓，结果反倒不那么重要了。根据过程我总结了几点结论：</p><ol><li>这种顺序执行对比的方式可能并不适合性能类的实验</li><li>ReflectAsm和JDK带的反射性能相差不大，而就只方法调用来看反射和直接调用性能差距也不大（怀疑网上是JDK1.7，而我用的1.8的原因）</li><li>强烈建议还是少用反射（本次拿出来的对比结果只是方法调用，实际在这之前我还做过包含对象实例化的对比，结果惨不忍睹）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近做央行征信项目在最初的一版设计尝试使用反射来进行方法调用，于是又”深入”的了解下反射的性能。&lt;br&gt;一开始看到网上的文章一篇看起来比较专
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>配置中心Apollo-初探Apollo</title>
    <link href="https://blog.hitime.wiki/2019/01/05/20190105-apollo-1/"/>
    <id>https://blog.hitime.wiki/2019/01/05/20190105-apollo-1/</id>
    <published>2019-01-05T09:21:28.000Z</published>
    <updated>2019-01-05T12:42:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介与简易安装"><a href="#简介与简易安装" class="headerlink" title="简介与简易安装"></a>简介与简易安装</h3><p>Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。<br>服务端基于 Spring Boot和Spring Cloud 开发，打包后可以直接运行，不需要额外安装 Tomcat 等应用容器。<br>Java 客户端不依赖任何框架，能够运行于所有 Java 运行时环境，同时对 Spring/Spring Boot 环境也有较好的支持。<br>.Net 客户端不依赖任何框架，能够运行于所有 .Net 运行时环境。<br>通过 <a href="https://github.com/ctripcorp/apollo/wiki/Quick-Start" target="_blank" rel="noopener">https://github.com/ctripcorp/apollo/wiki/Quick-Start</a> 可以进行快速安装开始了解 Apollo<br>安装启动登录后进入主页面<br><img src="/2019/01/05/20190105-apollo-1/apollo_1.png" alt="主页面"></p><h3 id="配置应用"><a href="#配置应用" class="headerlink" title="配置应用"></a>配置应用</h3><p>接下来新建 SpringBoot 项目进行 Apollo 配置管理测试<br>设置 Apollo Meta Server 地址来找到Apollo配置中心<br><img src="/2019/01/05/20190105-apollo-1/apollo_3.png" alt="设置Apollo Meta Server"><br>引入 apollo-client<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile group: <span class="string">'com.ctrip.framework.apollo'</span>, name: <span class="string">'apollo-client'</span>, version: <span class="string">'1.2.0'</span></span><br></pre></td></tr></table></figure></p><p>通过 properties 配置设置 <em>app.id</em> 来关联Apollo配置中心和应用程序，设置 <em>apollo.bootstrap.enabled</em> 来启用客户端中的 apollo-client<br><img src="/2019/01/05/20190105-apollo-1/apollo_2.png" alt="设置apollo客户端"></p><h3 id="使用配置信息"><a href="#使用配置信息" class="headerlink" title="使用配置信息"></a>使用配置信息</h3><p>将当前客户端的app.id的值在Apollo配置中心创建项目<br><img src="/2019/01/05/20190105-apollo-1/apollo_4.png" alt="创建项目"><br>新增配置 <em>spring.datasource.primary.jdbc-url</em> 并发布<br><img src="/2019/01/05/20190105-apollo-1/apollo_5.png" alt="设置apollo客户端"><br>在客户端通过接口获取键值以便观察配置值变化情况<br><img src="/2019/01/05/20190105-apollo-1/apollo_6.png" alt="设置apollo客户端"><br>启动测试程序通过 <em><a href="http://localhost:10008/getValue" target="_blank" rel="noopener">http://localhost:10008/getValue</a></em> 获取 <em>spring.datasource.primary.jdbc-url</em> 的值，可以看到已经通过拿到 Apollo 中最新的配置<br><img src="/2019/01/05/20190105-apollo-1/apollo_7.png" alt="设置apollo客户端"><br>再次在 Apollo 配置中心更新 <em>spring.datasource.primary.jdbc-url</em> 的值为 test，不重启客户端刷新页面便看到键值已经更新<br><img src="/2019/01/05/20190105-apollo-1/apollo_8.png" alt="设置apollo客户端"><br>Apollo 对键值的获取有多种方式完全能满足日常使用，对原本配置文件配置方式转换到 Apollo 也做了考虑，可以在配置页面选择文本的方式将 properties 中的配置信息导入<br><img src="/2019/01/05/20190105-apollo-1/apollo_9.png" alt="设置apollo客户端"><br>如果希望把日志相关的配置也放到 Apollo 中管理则可以通过设置 <em>apollo.bootstrap.eagerLoad.enabled=true</em> 方式在日志系统加载之前加载配置信息<br>总体来说 Apollo 对日常的配置信息管理已经做的非常好，后续文章我们将了解一些 Apollo 在应对特殊配置上的使用</p><blockquote><p>Apollo Github主页：<a href="https://github.com/ctripcorp/apollo" target="_blank" rel="noopener">https://github.com/ctripcorp/apollo</a><br>Apollo客户端使用：<a href="https://github.com/ctripcorp/apollo/wiki/Java客户端使用指南" target="_blank" rel="noopener">https://github.com/ctripcorp/apollo/wiki/Java客户端使用指南</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介与简易安装&quot;&gt;&lt;a href=&quot;#简介与简易安装&quot; class=&quot;headerlink&quot; title=&quot;简介与简易安装&quot;&gt;&lt;/a&gt;简介与简易安装&lt;/h3&gt;&lt;p&gt;Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置
      
    
    </summary>
    
    
      <category term="apollo" scheme="https://blog.hitime.wiki/tags/apollo/"/>
    
  </entry>
  
  <entry>
    <title>不可不说的Java“锁”事[转载]</title>
    <link href="https://blog.hitime.wiki/2018/12/30/20181230-lock/"/>
    <id>https://blog.hitime.wiki/2018/12/30/20181230-lock/</id>
    <published>2018-12-30T11:00:08.000Z</published>
    <updated>2018-12-30T11:22:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载自<a href="https://tech.meituan.com/Java_Lock.html" target="_blank" rel="noopener">https://tech.meituan.com/Java_Lock.html</a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8和Netty 3.10.6）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。</p><p>Java中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍，帮助大家更快捷的理解相关知识。下面给出本文内容的总体分类目录：<br><img src="/2018/12/30/20181230-lock/All_Lock.png" alt="All_Lock"></p><h3 id="1-乐观锁-VS-悲观锁"><a href="#1-乐观锁-VS-悲观锁" class="headerlink" title="1. 乐观锁 VS 悲观锁"></a>1. 乐观锁 VS 悲观锁</h3><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。</p><p>先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。</p><p>而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</p><p>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。<br><img src="/2018/12/30/20181230-lock/01_Java_Lock.png" alt="01_Java_Lock"><br>根据从上面的概念描述我们可以发现：</p><p>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。<br>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。<br>光说概念有些抽象，我们来看下乐观锁和悲观锁的调用方式示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------------- 悲观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="comment">// synchronized</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 操作同步资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 需要保证多个线程使用的是同一个锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyPublicResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="comment">// 操作同步资源</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- 乐观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();  <span class="comment">// 需要保证多个线程使用的是同一个AtomicInteger</span></span><br><span class="line">atomicInteger.incrementAndGet(); <span class="comment">//执行自增1</span></span><br></pre></td></tr></table></figure></p><p>通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？我们通过介绍乐观锁的主要实现方式 “CAS” 的技术原理来为大家解惑。</p><p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p><p>CAS算法涉及到三个操作数：</p><p>需要读写的内存值 V。<br>进行比较的值 A。<br>要写入的新值 B。<br>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p><p>之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类AtomicInteger的源码，看一下AtomicInteger的定义：<br><img src="/2018/12/30/20181230-lock/02_Java_Lock.png" alt="02_Java_Lock"><br>根据定义我们可以看出各属性的作用：</p><p>unsafe： 获取并操作内存的数据。<br>valueOffset： 存储value在AtomicInteger中的偏移量。<br>value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。<br>接下来，我们查看AtomicInteger的自增函数incrementAndGet()的源码时，发现自增函数底层调用的是unsafe.getAndAddInt()。但是由于JDK本身只有Unsafe.class，只通过class文件中的参数名，并不能很好的了解方法的作用，所以我们通过OpenJDK 8 来查看Unsafe的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------------- JDK 8 -------------------------</span></span><br><span class="line"><span class="comment">// AtomicInteger 自增方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var5;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">      var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">  &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">  <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- OpenJDK 8 -------------------------</span></span><br><span class="line"><span class="comment">// Unsafe.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> v;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">       v = getIntVolatile(o, offset);</span><br><span class="line">   &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">   <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。</p><p>后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。</p><p>CAS虽然很高效，但是它也存在三大问题，这里也简单说一下：</p><p>1.<strong>ABA问题</strong>。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</p><p>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</p><p>2.<strong>循环时间长开销大</strong>。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</p><p>3.<strong>只能保证一个共享变量的原子操作</strong>。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</p><p>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</p><h3 id="2-自旋锁-VS-适应性自旋锁"><a href="#2-自旋锁-VS-适应性自旋锁" class="headerlink" title="2. 自旋锁 VS 适应性自旋锁"></a>2. 自旋锁 VS 适应性自旋锁</h3><p>在介绍自旋锁前，我们需要介绍一些前提知识来帮助大家明白自旋锁的概念。</p><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p><p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。<br><img src="/2018/12/30/20181230-lock/03_Java_Lock.png" alt="03_Java_Lock"><br>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p><p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。<br><img src="/2018/12/30/20181230-lock/04_Java_Lock.png" alt="04_Java_Lock"><br>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p><p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p><p>在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock，本文中仅做名词介绍，不做深入讲解，感兴趣的同学可以自行查阅相关资料。</p><h3 id="3-无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#3-无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h3><p>这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。</p><p>首先为什么Synchronized能实现线程同步？</p><p>在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。</p><h4 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h4><p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？</p><p>我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。<br>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？</p><p>我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p><p><strong>Mark Word：</strong> 默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p><p><strong>Klass Point：</strong> 对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><h4 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h4><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p><p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><p>现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p><p>如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p><p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p><p>通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：<br><img src="/2018/12/30/20181230-lock/20181230190959.png" alt="Java_Lock"></p><h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p><p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p><p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p><p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p><p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p><p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p><p>整体的锁状态升级流程如下：<br><img src="/2018/12/30/20181230-lock/05_Java_Lock.png" alt="Java_Lock"><br>综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p><h3 id="4-公平锁-VS-非公平锁"><a href="#4-公平锁-VS-非公平锁" class="headerlink" title="4. 公平锁 VS 非公平锁"></a>4. 公平锁 VS 非公平锁</h3><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p><p>直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。<br><img src="/2018/12/30/20181230-lock/06_Java_Lock.png" alt="Java_Lock"><br>如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。</p><p>但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：<br><img src="/2018/12/30/20181230-lock/07_Java_Lock.png" alt="Java_Lock"><br>接下来我们通过ReentrantLock的源码来讲解公平锁和非公平锁。<br><img src="/2018/12/30/20181230-lock/08_Java_Lock.png" alt="Java_Lock"><br>根据代码可知，ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</p><p>下面我们来看一下公平锁与非公平锁的加锁方法的源码:<br><img src="/2018/12/30/20181230-lock/09_Java_Lock.png" alt="Java_Lock"><br>通过上图中的源代码对比，我们可以明显的看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。<br><img src="/2018/12/30/20181230-lock/10_Java_Lock.png" alt="Java_Lock"><br>再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</p><p>综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</p><h3 id="5-可重入锁-VS-非可重入锁"><a href="#5-可重入锁-VS-非可重入锁" class="headerlink" title="5. 可重入锁 VS 非可重入锁"></a>5. 可重入锁 VS 非可重入锁</h3><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法1执行..."</span>);</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doOthers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法2执行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。</p><p>如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p><p>而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。</p><p>还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。<br><img src="/2018/12/30/20181230-lock/11_Java_Lock.png" alt="Java_Lock"><br>但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。<br><img src="/2018/12/30/20181230-lock/12_Java_Lock.png" alt="Java_Lock"><br>之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。</p><p>首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。</p><p>当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。</p><p>释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。<br><img src="/2018/12/30/20181230-lock/13_Java_Lock.png" alt="Java_Lock"></p><h3 id="6-独享锁-VS-共享锁"><a href="#6-独享锁-VS-共享锁" class="headerlink" title="6. 独享锁 VS 共享锁"></a>6. 独享锁 VS 共享锁</h3><p>独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。</p><p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</p><p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p><p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p><p>下图为ReentrantReadWriteLock的部分源码：<br><img src="/2018/12/30/20181230-lock/14_Java_Lock.png" alt="Java_Lock"><br>我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。</p><p>在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。</p><p>那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。<br>在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。</p><p>在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示<br><img src="/2018/12/30/20181230-lock/15_Java_Lock.png" alt="Java_Lock"><br>了解了概念之后我们再来看代码，先看写锁的加锁源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState(); <span class="comment">// 取到当前锁的个数</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 取写锁的个数w</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123; <span class="comment">// 如果已经有线程持有了锁(c!=0)</span></span><br><span class="line">    <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread()) <span class="comment">// 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)    <span class="comment">// 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">    setState(c + acquires);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) <span class="comment">// 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current); <span class="comment">// 如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><ul><li>这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount(c); ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。</li><li>在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁(c!=0)，则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。</li><li>如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</li><li>如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。</li><li>如果c=0,w=0或者c&gt;0,w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！<br>tryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</li></ul></blockquote><p>因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。</p><p>接着是读锁的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;                                   <span class="comment">// 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。</p><p>此时，我们再回头看一下互斥锁ReentrantLock中公平锁和非公平锁的加锁源码：<br><img src="/2018/12/30/20181230-lock/16_Java_Lock.png" alt="Java_Lock"><br>我们发现在ReentrantLock虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>本文Java中常用的锁以及常见的锁的概念进行了基本介绍，并从源码以及实际应用的角度进行了对比分析。限于篇幅以及个人水平，没有在本篇文章中对所有内容进行深层次的讲解。</p><p>其实Java本身已经对锁本身进行了良好的封装，降低了研发同学在平时工作中的使用难度。但是研发同学也需要熟悉锁的底层原理，不同场景下选择最适合的锁。而且源码中的思路都是非常好的思路，也是值得大家去学习和借鉴的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载自&lt;a href=&quot;https://tech.meituan.com/Java_Lock.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://tech.meituan.com/Java_Lock.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 i
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL事务、隔离级别和锁</title>
    <link href="https://blog.hitime.wiki/2018/12/22/2018122201/"/>
    <id>https://blog.hitime.wiki/2018/12/22/2018122201/</id>
    <published>2018-12-22T12:39:24.000Z</published>
    <updated>2018-12-22T12:39:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h3><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p><blockquote><ul><li>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</li><li>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</li><li>事务用来管理 INSERT/UPDATE/DELETE 语句   </li></ul></blockquote><h4 id="1-1-事务特性"><a href="#1-1-事务特性" class="headerlink" title="1.1. 事务特性"></a>1.1. 事务特性</h4><p>原子性（<strong>A</strong> tomicity，或称不可分割性）、一致性（<strong>C</strong> onsistency）、隔离性（<strong>I</strong> solation，又称独立性）、持久性（<strong>D</strong> urability）。</p><blockquote><ul><li>原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li><li>一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li><li>隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul></blockquote><h4 id="1-2-事务并发问题"><a href="#1-2-事务并发问题" class="headerlink" title="1.2. 事务并发问题"></a>1.2. 事务并发问题</h4><blockquote><ul><li><strong>脏读：</strong> 事务 A 读取了事务 B 更新的数据，然后B回滚操作，那么 A 读取到的数据是脏数据</li><li><strong>不可重复读：</strong> 事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果不一致。</li><li><strong>幻读：</strong> 系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li></ul></blockquote><h3 id="2-隔离级别"><a href="#2-隔离级别" class="headerlink" title="2. 隔离级别"></a>2. 隔离级别</h3><p><strong>读未提交</strong><br>事务的最低隔离级别，在这种隔离级别下，一个事务可以读取另外一个事务未提交的数据。</p><p>事务 T 在读数据的时候并未对数据进行加锁，事务 T 在修改数据的时候对数据增加行级共享锁<br>T1 在读取数据时，T2 可以对相同数据进行读取、修改。因为 T1 没有进行任何锁操作；当 T2 对记录进行修改时，T1 再次读取数据可以读取到 T2 修改后的数据。因为 T2  对数据进行修改只增加了行级共享锁，T1 可以再增加共享读锁进行数据读取（尽管 T2 没有提交事务）</p><p>如上所述，这种隔离级别，会导致脏读现象。</p><p><strong>读已提交</strong><br>在一个事务修改数据过程中，如果事务没有进行提交，其他事务不能读取该数据。</p><p>事务T在读取数据时增加行级共享锁，读取一旦结束，立即释放；事务T在修改数据时增加行级排他锁，直到事务结束才释放。<br>T1 在读取数据的过程中，T2 也可以对相同数据进行读取，但是不能进行修改（ T1 增加的是共享锁，T2 也可以增加共享锁，但是不能增加排他锁）。T1 读取结束后，会立即释放共享锁，这时 T2 可以增加排他锁，对数据进行修改，而此时 T1 既不能对数据进行读取也不能进行修改，直到 T2 事务结束。</p><p>如上所述，这种隔离级别，解决了脏读问题，但是不能解决不可重复读现象。</p><p><strong>可重复读</strong><br>事务T在数据读取时，必须增加行级共享锁，直到事务结束；事务T在修改数据过程中，必须增加行级排他锁，直到数据结束。</p><p>T1 在读取数据的过程中，T2 也可以对相同数据进行读取，但是不能进行修改（ T1 增加的是共享锁，T2 也可以增加共享锁，但是不能增加排他锁）。直到 T1 事务结束后，才会释放共享锁，这时 T2 才可以增加排他锁，对数据进行修改。</p><p>如上所述，这种隔离级别，解决了不可重复读现象，但是这种隔离级别解决不了幻读的问题</p><p>T1 进行查询，读取了10条记录，并对十条记录增加了行级锁，此时 T2 是无法对这10行数据进行修改操作的，但是由于没有表级锁，它可以增加一条满足 T1 查询条件的记录。随后 T1 在进行查询时，会发现虽然10条记录没有改变，但是突然多了一条记录。</p><p><strong>串行化</strong><br>产生幻读是由于没有进行范围查询时没有增加范围锁。</p><p>事务 T 在读取数据时，必须先增加表级共享锁，直到事务结束才释放；事务 T 在修改数据时，必须先增加表级排他锁，直到事务结束才释放。</p><p>T1 在读取 A 表时，增加了表级共享锁，此时 T2 也可以读取 A 表，但是不能进行任何数据的修改，直到 T1 事务结束。随后 T2 可以增加对 A 表的表级排他锁，此时 T1 不能读取 A 表中的任何数据，更不能进行修改。</p><p>如上所述，可串行化解决了脏读、不可重复读、幻读等读现象，但是隔离级别越来越高的同时，在并发性上也就越来越低。<br><img src="/2018/12/22/2018122201/20181222203726.png" alt="隔离级别"></p><h3 id="3-锁"><a href="#3-锁" class="headerlink" title="3. 锁"></a>3. 锁</h3><p>总的来说，InnoDB共有七种类型的锁：</p><blockquote><ol><li>共享/排它锁(Shared and Exclusive Locks)</li><li>意向锁(Intention Locks)</li><li>记录锁(Record Locks)</li><li>间隙锁(Gap Locks)</li><li>临键锁(Next-key Locks)</li><li>插入意向锁(Insert Intention Locks)</li><li>自增锁(Auto-inc Locks)</li></ol></blockquote><p><strong>共享锁/排它锁</strong><br>共享锁又称为读锁，简称 S 锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</p><p>排他锁又称为写锁，简称 X 锁，顾名思义，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。</p><p><strong>意向锁</strong><br>意向锁分为意向共享锁和意向排他锁，InnoDB 实际应用中，使用的就是意向锁。</p><p>意向共享锁，简称 IS，其作用在于：通知数据库接下来需要施加什么锁并对表加锁。如果需要对记录 A 加共享锁，那么此时 InnoDB 会先找到这张表，对该表加意向共享锁之后，再对记录 A 添加共享锁。</p><p>意向排他锁，简称 IX，其作用在于：通知数据库接下来需要施加什么锁并对表加锁。如果需要对记录 A 加排他锁，那么此时 InnoDB 会先找到这张表，对该表加意向排他锁之后，再对记录 A 添加共享锁。</p><p><strong>记录锁</strong><br>我们已经知道 InnoDB 的细粒度锁是实现在索引记录上的，InnoDB 的索引有两类，<strong>聚集索引</strong>与<strong>二级索引</strong>，InnoDB 每个表都会有一个聚集索引，如果定义了PK，那么PK就是聚集索引，如果没有定义PK那么第一个 unique index 是聚集索引，否则 InnoDB 会创建一个隐藏的 row-id 作为聚集索引。<br>聚集索引是如此重要，是因为 InnoDB 的索引和数据时存储在一起的，聚集索引的叶子节点存储的就是行记录。<br>而二级索引的叶子节点存储的是 PK 值，所以就导致了 InnoDB 的二级索引实际上会扫描两遍，第一遍由二级索引找到 PK，第二遍通过 PK 找到行记录。</p><p><strong>间隙锁</strong><br>间隙锁封锁的是索引记录中的间隔，间隙锁是在 MySQL 隔离级别是RR的时候才会生效，如果把数据库隔离级别降低到<strong>读已提交</strong>，间隙锁会自动失效。一般标准情况下<strong>可重复读</strong> 隔离级别下能解决不可重复读（当行修改）的问题，但是不能解决幻读的问题，但是InnoDB通过间隙锁，保证了对读取范围加锁，从而避免了幻读。</p><p><strong>临键锁</strong><br>临键锁是记录锁和间隙锁的组合，它的封锁范围既包含索引记录，也包含索引区间本身，临键锁的目的也是为了避免出现幻读。</p><p><strong>插入意向锁</strong><br>意向锁的一种，也称为<strong>意向排它锁</strong>。</p><p><strong>自增锁</strong><br>auto_increment在MySQL中很常见，通常会将主键ID设置为自增长，自增的幅度可以通过auto_increment_offset(起始数字)和auto_increment_increment(自增幅度，每次增加n个数字)两个参数进行控制，可以实现偶数自增以及奇数自增。</p><p><strong>总结</strong><br>InnoDB 的 select 操作是用快照读，可以提高读读并发<br>InnoDB 的 update 和 delete 操作为了保证数据的强一致，使用强互斥锁，保证同一行记录修改和删除的串行性。<br>InnoDB 使用插入意向锁，提高插入并发<br>InnoDB 使用间隙锁和临键锁可以避免幻读的发生</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-事务&quot;&gt;&lt;a href=&quot;#1-事务&quot; class=&quot;headerlink&quot; title=&quot;1. 事务&quot;&gt;&lt;/a&gt;1. 事务&lt;/h3&gt;&lt;p&gt;MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从平面到立体——记苏州市场行</title>
    <link href="https://blog.hitime.wiki/2018/12/17/20181217_suzhou/"/>
    <id>https://blog.hitime.wiki/2018/12/17/20181217_suzhou/</id>
    <published>2018-12-17T09:34:43.000Z</published>
    <updated>2018-12-17T14:38:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="紧凑高效的苏州行"><a href="#紧凑高效的苏州行" class="headerlink" title="紧凑高效的苏州行"></a>紧凑高效的苏州行</h3><p>坐在办公室时，我努力的理解由前线人员反馈给主管再由主管通过PDCA会议紧凑的反馈给产品经理的需求。努力的模拟着我所要设计的功能真实的场景以及场景之外的异常情况。“应该出去看看”，我时常在想。我们不断在了解竞品公司的营销方案和系统设计，极力保证我们是走在“提高人效”的路上。但是实际场景是不是如我所想像的那样？<br>2018年12月15日我有幸成为苏州市场行的一员，通过紧凑高效的一天我们不光了解了竞品公司系统在市场上的反响，还从市场定价策略、市场促销策略和市场品牌策略等方面对公司在市场中有了更立体的认识。</p><h3 id="冷清的车市场温暖的交谈"><a href="#冷清的车市场温暖的交谈" class="headerlink" title="冷清的车市场温暖的交谈"></a>冷清的车市场温暖的交谈</h3><p>早会破冰后我跟随结对的销售文杰走在去市场的路上。路程不远，1公里的路上我听他讲述了昨天因为实名认证问题导致订单被卡在晚上8点50分才放款的遭遇。“这个车商肯定做不了”，他无奈的笑笑说道。他又补充道，“公司风控做的严是应该的，这是为了我们好”。<br>到达市场，因为是周六的缘故看起来冷冷清清的，偌大的市场里只有稀稀拉拉的人在擦车看车。我们进到一家车商里面和老板寒暄了几句便坐下看历史做过的订单。打开手机文杰看见需要更新跟我说“你看，有更新一直在更新，更新说明又会让我们省很多事情”，他看了看更新列表然后点击更新后又说道，“上次上线了一个GPS免录，扫一下GPS条码就有信息了，特别方便”。听到这番话让我触动很大，让我想起了常说的那句话，“前端不负后端，后端不负前端”。<br>我们走访了周边的车商聊了聊市场的规模、车辆品质以及购车群体等情况。看着琳琅满目的车辆以及文杰对公司的前景的看好让我在这个冷清的市场有了温暖的感觉。</p><h3 id="畅所欲言的交流"><a href="#畅所欲言的交流" class="headerlink" title="畅所欲言的交流"></a>畅所欲言的交流</h3><p>下午，我们回到办公室，对上午的所见所闻进行了简单的交流。然后和苏州城市经理周尔刚聊了聊苏州的市场背景以及他们在当地的策略。从谈话中我们了解到苏州市场因为私人代理和竞品公司的恶意返点让整个行业都举步维艰，我们公司的在市场上的产品策略和风控策略还没有形成独特的风格。这就导致车商在向客户推荐金融方案时很难第一时间想到我们公司，我们能做的就是尽量提高我们使用体验通过客情维护让更多的车商记得我们。<br>另外我们还了解到我们的一些提单策略和其他公司略有不同，很多时候在订单都已经走到签约阶段突然被拒绝，这让客户体验非常不好。<br>对最近新做的抵押系统尔刚也有一些看法，说道，“有不少抵押专员和运营反馈新系统不太好用”。对此我解释因为我们的抵押流程之前一直在线下处理，突然搬到线上肯定大家会有些不适应。如果使用一段时间后有任何异常或不理解的地方都可以及时反馈，共同打造一套易用的系统。<br>从交流中我们还从同事口中了解到了其他公司的产品的一些特点，认识到我们现阶段还有很多不足。也让我们从后端走到了前端更加立体的了解了我们公司。</p><h3 id="行程掠影"><a href="#行程掠影" class="headerlink" title="行程掠影"></a>行程掠影</h3><p><img src="/2018/12/17/20181217_suzhou/921545056659_.pic_hd.jpg" alt="清晨出发"><br>清晨出发<br><img src="/2018/12/17/20181217_suzhou/951545056660_.pic_hd.jpg" alt="到达苏州"><br>到达苏州<br><img src="/2018/12/17/20181217_suzhou/961545056660_.pic_hd.jpg" alt="走访市场"><br>走访市场<br><img src="/2018/12/17/20181217_suzhou/971545056662_.pic_hd.jpg" alt="走访市场"><br>走访市场<br><img src="/2018/12/17/20181217_suzhou/WechatIMG99.jpg" alt="德易的车辆介绍牌"><br>德易的车辆介绍牌<br><img src="/2018/12/17/20181217_suzhou/1001545056668_.pic_hd1.jpg" alt="畅所欲言的交流"><br>畅所欲言的交流</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;紧凑高效的苏州行&quot;&gt;&lt;a href=&quot;#紧凑高效的苏州行&quot; class=&quot;headerlink&quot; title=&quot;紧凑高效的苏州行&quot;&gt;&lt;/a&gt;紧凑高效的苏州行&lt;/h3&gt;&lt;p&gt;坐在办公室时，我努力的理解由前线人员反馈给主管再由主管通过PDCA会议紧凑的反馈给产品经理的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linus，一生只为寻找欢笑</title>
    <link href="https://blog.hitime.wiki/2018/12/14/Linus%EF%BC%8C%E4%B8%80%E7%94%9F%E5%8F%AA%E4%B8%BA%E5%AF%BB%E6%89%BE%E6%AC%A2%E7%AC%91/"/>
    <id>https://blog.hitime.wiki/2018/12/14/Linus，一生只为寻找欢笑/</id>
    <published>2018-12-14T15:58:38.000Z</published>
    <updated>2018-12-14T16:01:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>[转载：<a href="https://www.oschina.net/news/72562/linus-smell]" target="_blank" rel="noopener">https://www.oschina.net/news/72562/linus-smell]</a><br><img src="/2018/12/14/Linus，一生只为寻找欢笑/074758_oIWK_1774694.jpg" alt="桥"><br>每个人桌面上一台电脑，这曾经是无数计算机先驱的梦想，这个梦想很早就实现了，在1997年，乔老师和比老师就说过，「比尔，我们共同控制了100%的桌面 系统市场」，当然乔老师没说的是，比老师控制了97%，乔老师还不到3%。时至今日，乔老师走了，比老师颓了，移动终端把传统的 PC 市场冲击的七零八落。普通用户都知道了Windows、Android、OS X 、iOS、BlackBerry等等，但是，他们依然不了解的是另一款在计算机发展史上起到了革命性作用的操作系统：Linux！</p><p>当大家使用 Google 搜索时，使用 Kindle 阅读时，使用淘宝购物时，使用 QQ 聊天时，很多人并不知道，支撑这些软件和服务的，是后台成千上万台 Linux 服务器，它们时时刻刻都在进行着忙碌的运算和数据处理，确保数据信息在人、软件和硬件之间安全的流淌。可以这么说，世界上大部分软件和服务都运行在 Linux 操作系统之上，神马云计算、大数据、移动互联网，说起来风起云涌，其实没有 Linux 全得趴窝（微软除外）。</p><p>但是，Linux 和它的缔造者 Linus Torvalds 一样低调，这么牛逼的一个物件，居然只有程序员知道它的传奇，这不科学！所以我准备在这个系列中写写Linus Torvalds：他是 Linux 和 Git 的缔造者，他是一个传统的黑客，与沃兹一样，少年成名，崇尚自由，一生只为寻找欢笑，他，是一个真正的程序员。</p><blockquote><p>注：为了防止大家把 Linux 和 Linus 搞混，我在后面的文章中统一采用 Linus 的中文译名：李纳斯。</p></blockquote><p>李纳斯在2001年出过一本自传，叫做《Just for Fun》，是他和大卫·戴蒙合著的，当年我有幸读到这本书，了解了很多李纳斯的生平轶事，那时我就琢磨，这个天才已经达到人生的巅峰了吧，结果这位兄台并未停止前进的步伐，转手就在2005年搞出了分布式版本控制系统Git，目前几乎全世界的程序员都在用Git管理他们的代码，著名网站Github就是基于Git构建的。无论是 Linux 还是Git，得一即可得天下，结果这哥们以一己之力发起了俩项目，而且都是主力开发人员。最终的结果是，成全了程序员，陶冶了用户，造福了一方百姓。正如李纳 斯自己所言：「My name is Linus, and I am your God.」</p><h4 id="Linus（一）——生命的意义"><a href="#Linus（一）——生命的意义" class="headerlink" title="Linus（一）——生命的意义"></a>Linus（一）——生命的意义</h4><p>1969 年末，李纳斯出生于芬兰的赫尔辛基市，算是赶上了60后的尾巴。小时候他是个其貌不扬的孩子，除了一个鼻子长的「富丽堂皇」之外乏善可陈。他为了让鼻子看 上去小一些，经常戴上眼镜就不愿意摘下来，这个策略和现在的很多大脸女生购买三星的 Galaxy Note 手机有异曲同工之妙。幼时的李纳斯不修边幅邋里邋遢，不怎么费劲数学和物理就学得极好，社交圈却一塌糊涂，他母亲经常和别人说，这孩子非常好养，只要把他 放到一个有电脑的小黑屋里，然后再往里扔点薯条和意大利面，就行了。李纳斯对此表示认同。</p><p>李纳斯把年幼的自己定位成 Nerd（书呆子），但是从他的自传里我却感受到了这位天才的有趣之处。他在书的前言里写到：</p><blockquote><p>我对生命的意义有种理论。我们可以在第一章里对读者解释生命的意义何在，这样就可以吸引住他们。一旦他们被吸引，并且付钱买了书，剩下的章节里我们就可以胡扯了。（注：做人要厚道啊）</p></blockquote><p>关 于生命的意义，李纳斯的解释是，有三件事具有生命的意义。它们是你生活当中所有事情的动机。第一是生存，第二是社会秩序，第三是娱乐。生活中所有的事情都 是按这个顺序发展的，娱乐之后便一无所有。因此，从某种意义上来说，生活的意义就是要达到第三个阶段。你一旦达到了第三个阶段，就算成功了。但首先要越过 前两个阶段。</p><p>为什么李纳斯会这么说呢，我摘段原文给大家看看，非常有趣：</p><blockquote><p>李纳斯：我给你举个例子来说明这一观点。最明显的是性，它开始只是一种延续生命的手段，后来变成了一种社会性的行为，比如你要结婚才能得到性。再后来，它成了一种娱乐。</p></blockquote><blockquote><p>大卫：性为什么是娱乐?</p></blockquote><blockquote><p>李纳斯：好吧，我是在对牛弹琴。我举一个别的例子。</p></blockquote><blockquote><p>大卫：别别，还是说说性吧</p></blockquote><blockquote><p>李纳斯：它是在另一个层次上的blablabla……</p></blockquote><blockquote><p>大卫(自言自语)：哦，参与就是娱乐，而不是在一旁观看。好，我明白了。</p></blockquote><p>那生存、社会秩序和娱乐又是如何与技术扯上关系的呢？</p><h4 id="Linus（二）——天才也疯狂"><a href="#Linus（二）——天才也疯狂" class="headerlink" title="Linus（二）——天才也疯狂"></a>Linus（二）——天才也疯狂</h4><p>李纳斯是这么解释的，技术的诞生同样是为了人类的生存，而且是为了让人生活的更好。汽车让人跑的更快，飞机让人飞得更高，互联网让人懂得更多，手机让人通信更快，一旦这些技术成了规模，就要并入社会秩序，然后下一个阶段就是娱乐，别看手机现在就是个打电话的工具，但是很快会进入娱乐阶段……（12年后的今天，手机已经彻头彻尾变成了一个娱乐工具，打电话反而成了附属功能）。</p><p>李纳斯说：「一切事物都将从生存走向娱乐，但这并不意味着在某个局部地区没有倒退的现象，而且毫无疑问许多地方都有这种情况。有时事物的发展往往分裂的。」</p><p>从这些内容我们可以看出，李纳斯有自己的一套理论，而且能自圆其说，其实每个人都有自己的理论，一件事做或者不做，都是自己说服自己，每一次进步，要么是推翻自己的理论，要么是完善自己的理论。李纳斯在很小的时候就建立了自己的理论领地，那就是数学、物理、逻辑，最后是计算机，所以他绝不是自己描述的 Nerd，而是一个大智若愚的牛娃，就像射雕里的郭靖一样，看着傻，其实比谁都精，脑子里装的都是十年二十年后的事儿。而且李纳斯比郭靖牛的地方是，就一个启蒙老师，还是自己的外公，和郭靖一比，高下立判！李纳斯基本上就是个自学成才的典范。</p><p>李纳斯的外公是赫尔辛基大学的一位统计学教授，数学家。他有一台Commodore VIC-20计算机（Commodore 是与苹果公司同时期的个人电脑公司，曾经创造过一系列辉煌，1994年破产），这台电脑的主要功能就是没有功能，你唯一能做的事情就是用 Basic 语言在上面编写自己的程序，老爷子当年就是这么做的，比如做一些数学运算和公式计算等。但是老爷子年老眼花，也不愿意打字，于是就把自己的外孙李纳斯放在腿上，让他帮助录入写在纸片上的程序。这种很有场面感的场景一再出现后，李纳斯除了对数学有了初步的认识，同时也把计算机玩的娴熟，很快他就在外公的指导下开始编写自己的程序。</p><blockquote><p>评：很多大师级的人物，很小的时候就能在某个领域内头角峥嵘，展现出一些东西，然后经过长期的练习和创作，最终成为一代传奇。在这个过程里，环境是很重要的，逆境出人才基本上是个伪命题，这句话唯一的作用就是遇到困难时给自己打打鸡血。李纳斯就是个高知子弟，10岁人家就开始玩计算机了，我们10岁在干什么，打沙包么？甩方宝么？即使你在计算机方面有出众的天赋，但18岁以前连计算机的面儿都没见过，你就只能默默的牛逼了。等你真正开始展现出自己才华的时候，人家操作系统已经开发出来了，一入世就差别人十年的身位，除了冷冷的绝望，你还能感受到什么？</p></blockquote><p>所以现在人们没事就北上广深杭，不是喜欢人多嘴杂空气差，而是在这些一线城市可以接触更多的人和事物，见更高的山，渡更宽的河。不是为了情怀，而是拥有格局。见都没见过，还同一个起跑线呢，一跑就得趴窝。所以，无论这些地方环境多恶劣，竞争多激烈，来的永远多过走的，不为别的，只是为了缓解些许绝望的感觉……</p><p>李纳斯用外公的计算机学会了 Basic 语言，并开始编写各种简单有趣的游戏，然后他又发现了 Basic 并不是计算机唯一能理解的语言，在它的下面，还有一种语言是由0和1组成，可以直接被计算机识别，于是李纳斯又开始用机器码编程，这次他可以控制更多计算机的细节，他与机器变得更加亲密。然后李纳斯就开始上中学了，中学的几年于他而言，其实没有太大变化，因为那些年他几乎都是坐在电脑前面度过的，在这个阶段，他熟练的掌握了汇编语言。</p><p>终于有一天，李纳斯向编程世界挺进的步伐变得缓慢下来，因为他上大学了，原因之一是他必须集中精力读书，原因之二是找不到什么项目去做。还有一件事，李纳斯开始服兵役了，那段时光对他来说是如此特殊：</p><blockquote><p>在手执武器上了一个月的「体育课」之后，我便觉得在我有生之年完全有资格从此一动不动，享受平静的生活了。惟一可做的事情就是把编码打入键盘，或者手里端着一瓶比尔森啤酒！</p></blockquote><h4 id="Linus（三）——改变一生的书籍"><a href="#Linus（三）——改变一生的书籍" class="headerlink" title="Linus（三）——改变一生的书籍"></a>Linus（三）——改变一生的书籍</h4><p>终于，让李纳斯痛苦不堪的兵役终于结束了，除了敲锣打鼓欢庆重生之外，他开始继续拓展自己的编程之路，这时候，生命中最重要的一本书出现了，书的名字叫做《操作系统：设计和实现》，作者是 Andrew S. Tanenbaum。用李纳斯的原话表述就是「这本书把我推上了生命的高峰」。</p><p>那个时代 Unix 已经开发出来了。最早 Unix 是用汇编写的，开发过程中 Unix 的两位创始人Ken Thompson 和 Dennis Ritchie觉得用汇编写程序实在是太苦逼了，男人应该对自己好一点！于是老哥俩决定用高级语言来完成下一个版本，他们首先尝试了Fortran，失败！然后又基于BCPL（Basic Combined Programming Lanugage）创建了 B 语言，B 语言可以被认为是那个时代的解释型语言，不能直接生成机器码，效率上完全没法满足系统的需求，再次失败！我们都知道，一再失败的情况下总会有一位英雄人物挺身而出，这次是 Dennis Ritchie，他从失败的大坑中爬起来拍拍土抹抹泪，继续对 B 语言进行改造。这次 Dennis 为 B 增加了数据类型，并让 B 语言能够直接编译为机器码，然后又为这门语言起了个极其响亮的名字：「New B」，读一读神清气爽，念一念气冲云霄，从此一代语言巨星冉冉升起，40年后依然排在兵器排名榜第一位，怎一个牛字了得！当然，Dennis可能考虑了十几年后中国人民的感受，把「New B」改为了 C 语言，并用 C 语言重新编写了 Unix 的内核，Unix 与 C 从此珠联璧合，长相思守，再也无法分离。</p><p>操作系统、Unix 和 C 语言可以说是李纳斯心目中神山上的三座圣杯，为了至高无上的荣耀，他首先要攀上峰顶，把这三座圣杯捧在手中，然后再琢磨建造自己的宫殿的事儿。在那一年的夏天，李纳斯开始了高强度的阅读和学习，用他的话说就是做了两件事，「一件事是什么都没做，另一件事是读完了719页的《操作系统：设计和执行》。那本红色的简装本教科书差不多等于睡在了我的床上」。</p><p>李纳斯认为，Unix 是一个简洁、干净的操作系统，在 Unix 上的大部分任务都是通过一些基本操作完成的，这些操作被成为「System Call」，顾名思义，这些操作就是你对系统的呼叫，系统通过响应你的呼叫完成工作。比如 fork、clone（创建子进程），比如 open、close、read、write（文件访问）。这些基本的系统调用通过组合可以完成大部分功能。同时，Unix 还提供了极为强大的IPC（进程间通信）方式：pipe（管道）。很多工作在GUI（图形界面）软件环境下的读者，最常用的IPC操作可能是复制、粘贴、鼠标拖拽，这些操作虽然简单，但是必须由人来完成，想要自动化就很困难。而这些在 Unix 上实现起来就像大自然一样自然，你只需要在程序之间开辟出一段缓冲区作为管道，然后父进程和子进程就可以通过这个管道实现进程间通信了。举个例子，以前给大家介绍的查找历史命令的脚本，就利用了管道的功能，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history | grep apache</span><br></pre></td></tr></table></figure><p>这行命令的含义就是查找包含 apache 的历史命令，其中特殊字符【 | 】用来告诉命令行解释器（Shell）将前一个命令的输出通过「管道」作为接下来的一行命令的输入，就这样，一个简单的进程间通信就完成了。</p><p>总之，李纳斯在读完这本书之后，就像郭靖修习了九阴真经全本一样，对机器和代码的世界有了更为透彻的认知，接下来的事情就是等待一个打造传奇的机会。</p><p>等待的过程中，李纳斯也没闲着，他又开始编程了。好的程序员对编程的喜爱是溢于言表的，以下摘录一些李纳斯的编程感想：</p><blockquote><p>对于喜爱编程的人来说，编程是世界上最有趣的事，比下棋有趣得多！因为你可以自己制订游戏规则，而你制定什么样的规则，也就会随之出现与此规则相符合的结果。</p></blockquote><blockquote><p>在电脑世界中，你就是创世者，你对所发生的一切拥有最终的控制。如果你功力深厚，你可以是上帝――在一个较小的层面上。</p></blockquote><blockquote><p>你可以建筑一个这样的房子，有一个活板门，既稳固又实用。但是每个人都可以看出一个仅仅以坚固实用为目的的树上小屋和一个巧妙地利用树本身特点的美妙小屋之间的差异。这是一个将艺术和工程融为一体的工作。编程与造树上小屋有相似之外……在编程中，实用的考虑往往被置于有意思、美观优雅或有震撼力的考虑之后。</p></blockquote><p>在代码的世界里，李纳斯就是一个诗人！</p><h4 id="Linus（四）——Linux-诞生"><a href="#Linus（四）——Linux-诞生" class="headerlink" title="Linus（四）——Linux 诞生"></a>Linus（四）——Linux 诞生</h4><p>Unix 始于上个世纪60年代，在70年代得到了迅猛的发展，这时候的李纳斯还躺在祖父公寓里的摇篮里睡大觉，如果不是后来 Unix 王国自乱阵脚，出现阵营分裂和法律纠纷，可能 Linux 系统根本都不会出现。真实的情况是，Unix 浪费了大把的时间和机会，似乎就是为了等待这个大鼻子、头发纷乱的芬兰小子长大，然后一决高下。李纳斯赢得了自己的时间，他一刻不停的磨练自己的技艺，在清晨的微光中练习算法，在赫尔辛基的雪山上编译代码，随时随地补充的粮草和武器。二十一年之后，李纳斯抚着雪亮的刀锋上路了，他要去追寻属于程序员的最高荣耀。</p><p>1991年一月，李纳斯花费了三千五百美元，分期付款购买了一台杂牌组装电脑，内存4兆，CPU 33兆赫，还有一台14英寸的显示器，然后又买了 MINIX 操作系统，用十六张软盘把这个操作系统装到了计算机里。之后，李纳斯又用了一个月的时间，了解了 MINIX 的好和不好，并把这个系统改装成了自己得心应手的「战斗机」，开始了战斗的人生。就是在这台电脑上，催生了 Linux 的初始版本。</p><p>Linux 的诞生离不开 MINIX，MINIX 是 Mini Unix 的缩写，是 Andy Tanenbaum 教授编写的迷你版的 Unix 操作系统，源代码可以提供给大学和学生，用于操作系统教学，采用了微内核设计。其中的代码还作为《操作系统：设计与实现》的示例程序，这本书我们在 Linus（三）中提到过，给了李纳斯极大的启发。</p><p>李纳斯使用了 MINIX 之后，发现这个系统有很多缺陷，比如性能问题、内核问题、文件系统问题，最大的问题是终端仿真器，也就是我之前总提到的 Terminal，登录学校里的 Unix Server 和上网时，李纳斯都需要终端，但是 MINIX 无法满足这个需求。如果普通人遇到这种问题，估计就是发会呆然后洗洗睡了，或者说「你行你上啊」，李纳斯不是普通人！</p><p>他决定抛开 MINIX，从硬件层面开始，重新设计一个终端仿真器。牛人就是不同凡响，这个决定表明了李纳斯需要从 BIOS、CPU等硬件层面重新开发出一套系统，除此之外，还需要了解如何把信息写入显示器，如何读取键盘输入，如何读写调制解调器，早期储备的汇编语言和 C 语言能力终于派上了用场……</p><p>两个月之后，终端仿真器完成，对此李纳斯非常骄傲：</p><blockquote><p>对于我了不起的成就，萨拉（妹妹）是了解的。我把终端显示给她看，她盯着显示器看了大约五秒钟，看着上面是一串A和一串B，说了声「很好」，然后就没有然后了。我意识到我的成就并不辉煌，这犹如你指给人看你铺设的一条长长的柏油马路，但想向别人解释这条马路的意义是完全不可能的。</p></blockquote><blockquote><p>当时是三月，也可能是四月，就算彼得盖坦街上的白雪已经化成了雪泥我也不知道，当然我也并不关心。大部分时间我都穿着睡衣趴在相貌平平的计算机前面噼噼啪啪的敲打键盘，窗户上的窗帘遮得严严实实，把阳光和外部世界与我隔离开来。</p></blockquote><p>Linux 操作系统就这样开始了，一发不可收拾。李纳斯的当时编程状态是这样的：编程――睡觉――编程――睡觉――编程――吃饭――编程――睡觉――编程――洗澡――编程……</p><p>实现了终端仿真器之后，李纳斯马不停蹄，开始添加磁盘驱动和文件系统，那一年李纳斯还在上课，但是课程很简单，他唯一的课外活动就是参加每周三晚的同学聚会，这个长着大鼻子的技术天才，常常会因为担心自己缺乏社交能力和容貌丑陋而失眠，对那时的他来说，唯一有趣的事情就是把驱动程序写出来。于是他咬咬牙对自己说，还得干下去。（看来没有女神的好处就是可以写个操作系统出来，然后把自己叫做 上帝）。</p><p>随着工作的进展，终端仿真器正在开始向一个操作系统的方向发展，李纳斯显然也看清楚了这一点。</p><p>在整个创造 Linux 的过程中，我们没有看到李纳斯使用了什么样高级工具，估计那时也没有，整个系统基本上是一行行代码敲出来的，纯手工打造，这些先贤的编程功底和效率让我们叹为观止，所以，现在，我决定打开终端，输入 vi，然后键入：to be continued，感受一下李纳斯当年编程的风采……</p><p>随着李纳斯不断的敲击键盘，他的终端仿真程序也不停的扩张，从刚开始的小树苗长成了一株盘根错节的大树，树根牢牢的抓住土地，枝丫努力的伸向天空，花朵和果实开始在高远的天空中烁烁发光，所有的细节都在李纳斯的掌控之中。懂行的技术人员都看得出来，这个大鼻子的芬兰小子是准备开发一个操作系统啊。</p><p>是年6月份，李纳斯基本确定了要开发一个操作系统内核的计划，并开始着手搜集 Unix 操作系统标准的相关资料。1991年7月3日，格林威治时间上午10点钟，李纳斯在 MINIX 新闻组发出了一封求助邮件，寻求有关 Posix 标准的帮助，他在邮件中写道：</p><blockquote><p>目前我正在 MINIX 系统下做一个项目，对 POSIX 标准很感兴趣。有谁能向我提供一个机器可读的最新的 POSIX 规则？如果能有个 FTP 地址就更好了。</p></blockquote><p>这份公开的邮件是标识 Linux 问世的最早证据。邮件发出后不久，有人就寄来了厚厚的 POSIX 标准，同时赫尔辛基工学院的 Ari Lemke 也对李纳斯的邮件做出了响应，为李纳斯提供了一个 FTP 地址，用来上传他即将完成的操作系统。</p><blockquote><p>注：POSIX 全称是可移植操作系统接口（Portable Operating System Interface）。IEEE 最初制定 POSIX 标准，是为了提高 UNIX 环境下应用程序的可移植性。随着技术的发展，POSIX 开始不局限于 UNIX 系统，后续的 Linux 和 Windows NT 都部分的遵循了该标准。POSIX 在李纳斯开发的过程中起到了灯塔的作用，直接后果就是 Linux 系统从一开始就走在了正规军的康庄大道上，基本没有跑偏过。Linux 几乎可以适配各种类型的硬件体系结构。</p></blockquote><p>标准和 FTP 地址都有了眉目，李纳斯开始实现各种 System Call，以便让 Shell 运行起来。这段时间的工作让李纳斯时常感到灰心丧气，看着增加的代码量，工作似乎前进了一大步，但是检验一下功能又仿佛没有任何进展。有时候他还不得不放弃之前的想法和已经完成的代码实现，另辟蹊径重头再来，即使是在天才面前，代码也能让人欢喜让人忧。</p><p>终于 Shell 已经可以在新的操作系统上工作了，李纳斯开始编写拷贝（cp）和列表（ls）等程序。Shell 程序一旦完成，就好像完成了从0到1的飞跃，一切都变得无比顺利，李纳斯面前仿佛出现了一条阳关大道，一切都豁然开朗了，他说，要有光，于是就有了光。对于这种状态，李纳斯表示：「我很满意」，并且开始用「Linux」称呼这个操作系统。</p><p>这种满意非常重要，因为那个夏天李纳斯除了伏在电脑面前噼噼啪啪的敲击键盘，什么都没做。芬兰四月到八月的日子是一年中最美好的时光。人们到布满小岛的海上航行，去海滩上晒日光浴，到夏日小木屋中消遣时光。但是李纳斯，他只是在永无休止的编写程序，忘记了白天和黑夜，黑色的窗帘遮蔽了灿烂的阳光，也遮蔽了外面的世界。他唯一的想法就是，得赶紧把这该死的系统做出来！</p><p>1991年8月25日，李纳斯在MINIX 新闻组上发邮件做了一个调查，想知道大家希望这个新的操作系统具备什么特征。</p><p>1991年9月17日，李纳斯把已经完成的新操作系统上传到了Ari Lemke提供的 FTP 服务器上，并准备用「Freax」作为操作系统的最终代号，结果遭到了Ari Lemke的激烈反对。Ari Lemke对李纳斯说：</p><p>「李哥，您咋会想到用这么变态的名字命名操作系统呢？原来的Linux不挺好的嘛」</p><p>「那样不会显得自恋么？」</p><p>「您这样就不对了，操作系统是开天辟地的大事，人民群众都等着用您的名字命名呢，看看他们的眼神，您能辜负他们的期望吗？Linux 天生不就是用来了 Unix 遥相呼应的么？这是命，得认！」</p><p>「这……那我就不推辞了啊」</p><p>以上为意译，不过基本上和古代皇帝的黄袍加身是一个意思。新的操作系统最终以「Linux」命名，并在10年后名扬天下，20年后统治服务器领域，可谓 Linux 恒久远，Linus 永流传。</p><p>Linux 内核0.01版本终于发布了，虽然漫长的开发过程才刚刚开始，但李纳斯终于可以松口气了：</p><blockquote><p>瞧，我真的做出了点什么。我没有在骗你们。这就是我所做的……</p></blockquote><p>创造操作系统，就是去创造一个所有应用程序赖以生存的基础环境――从根本上来说，就是在制定规则：什么可以接受，什么可以做，什么不可以做。事实上，所有的程序都是在制定规则，只不过操作系统是在制定最根本的规则。——李纳斯</p><h4 id="Linus（五）——继续前行"><a href="#Linus（五）——继续前行" class="headerlink" title="Linus（五）——继续前行"></a>Linus（五）——继续前行</h4><p>Linux 从一诞生就被打上了开源的烙印，这一点对 Linux 的后续发展起到了至关重要的作用。从1991年内核0.01版本发布，到1994年1.0版本闪亮登场，世界各地无数的开发者为 Linux 提交了代码，李纳斯为 Linux 建立了讨论组 comp.os.linux，全世界爱好开源和 Linux 的程序员与黑客都在上面讨论问题，他们就像群蜂筑巢一样，不断的通过个体和群体的力量交替推进 Linux 的飞速发展。</p><p>李纳斯对自己说：嗯，没有任何东西可以阻挡 Linux 的普及！</p><p>这种感觉估计很多程序员都体会过，当你设计的算法得出了正确结果的时候，当你自以为解决了一个海森堡 bug（Heisenbug，表示不可重现）的时候，当你完成了一段精妙代码的时候，你摘下厚重的眼镜，推开铺满灰尘的书桌，打开办公室唯一的窗户，迎着夕阳把一只废弃的圆珠笔扔出窗外，然后冲着天空大喊：还有谁~~~？这是一种拔剑四顾心茫然的情怀。</p><p>李纳斯还不止于此。他不仅单枪匹马写出了 Linux 的内核，而且做出了开源的决定。他把 Linux 放到了互联网上，并且允许那些希望使用和改进它的人们根据开源协议修改和提交源代码。这两点对互联网的影响是极其深远的，估计李纳斯当年也没有想到，当时的两个小小的涟漪，经过时间和空间的放大，十几年后形成了一股互联网巨浪，到现在 Linux 依然处于风口浪尖。</p><p>对于 Linux 取得的成功，李纳斯将其归结为是由自己的缺点导致的：</p><blockquote><p>1、 我很懒散<br>2、 我喜欢授权给其他人</p></blockquote><p>其实这两个所谓的缺点，正是优秀程序员和领导者必备的要素，它们让 Linux 成为世界上最大的开源协作项目，为喜爱 Linux 的人们带来了最美好的技术和应用，现代的互联网几乎是运行在 Linux 之上的，可以说，李纳斯改变了世界，你每一次伐开心后在淘宝上买包包，都有李纳斯贡献的力量！</p><h4 id="Linus（六）——来到硅谷"><a href="#Linus（六）——来到硅谷" class="headerlink" title="Linus（六）——来到硅谷"></a>Linus（六）——来到硅谷</h4><p>1996年的春天，Linux 顺利发布了2.0版本。是年李纳斯27岁，这个芬兰小子已经慢慢厌倦了芬兰平淡无奇的日子和不眠不休的编程生活。对于一个技术天才来说，创造一套新的技术体系就像艺术家完成一个雕像一样，当一块粗砺的岩石在他的亲手打磨下逐渐显山露水，展现出其完美容颜的时候，后续的修修补补会让这些天才产生倦怠的感觉。他们需要更快的剑，更高的山和更强大的对手。尤其是期间李纳斯访问过两次美国之后，这种感觉变得愈发不可阻挡了。</p><p>说起来美国确实是个神奇的国度，这样一个移民国家中，居住了各种从不同国度不远万里跨海而来的种族，每个种族无论在基因上还是文化上都具有原来国家的特质，这些特质相互融合与对抗，让这块大陆上的人民更锐意进取，更开放，更自由，他们愿意去追求和接纳美好的事物，最终一不留神把美国搞成了世界文化的大熔炉，而开放的文化和环境又极大的激发了人们的想象力和创造力，近代和现代的科技成果几乎全部源于美国，要么是美国人搞的，要么是外国人在美国搞的。所以有时候我们也不用顾影自怜，嘲笑自己没有国产的操作系统和编程语言，因为其他国家也没有，或很少有，芬兰好不容易出了个天才少年，也没好好珍惜，最终落了个「流落」异国他乡的下场。</p><p>李纳斯一到美国就被这块新大陆吸引了，一切都是那么的新鲜和美好，他的感受与你第一次出国后在微信朋友圈发的「天是那么的蓝，云是那么的白」是一样一样的。李纳斯在自传中写道：</p><blockquote><p>我所参观的摩门教堂已有一百五十年的历史，却被照顾的很好，清洗后的教堂显示出亮丽的白色。要是在欧洲，所有的教堂都显得老旧不堪，像是蒙上了一层岁月的斑痕。看着这洁白亮丽的教堂，我脑海里产生的唯一联想竟然是迪斯尼乐园。因为它看起来太像是童话故事中的城堡，而不太是一个教堂了。</p></blockquote><blockquote><p>我记得自己徒步走过了金门大桥。在桥的这头时，我望着对岸的马林海岬，恨不得立刻就到对岸去徜徉在那美丽的群山之间。但等我真走到那边时，我几乎不愿意再挪动双腿……那时的我绝对想不到，在时隔六年以后的今天，我会坐在海风吹拂的海岬峰顶，一面俯瞰太平洋、旧金山湾、金门大桥和笼罩在雾中的旧金山城，一面对着大卫的录音机讲述着这一切。</p></blockquote><p>从美国回到芬兰之后，李纳斯对自己说，我要去美国。</p><p>当李纳斯透露出自己的就业计划之后，马上有多家公司递来橄榄枝，其中包括著名的 Linux 公司 Red Hat。这种感觉是如此美妙，就像你刚刚掏出一支香烟，面前已是千百个打火机舞动。但是李纳斯本着不加入任何一家 Linux 公司的原则，拒绝了 Red Hat，参加了另一个名不见经传的公司的面试，这家公司叫做 Transmeta，中译名「全美达」，你们可以从维基百科上查到这家公司，不过我打赌，知道这家公司的读者不会超过千分之一，这并不是咱们孤陋寡闻，因为美国人民刚开始也不知道这家公司在干嘛，全美达官网在1997年中上线，两年半后网站的建设情况是「This web page is not yet here」，又过了很久人们才从内部员工透露出的一点信息得知，这家公司似乎是搞处理器的。这是我所知道的唯一一家保密措施强过苹果的公司，如果不是李纳斯，这家公司就像是根本没有存在过。</p><p>就是这样一家公司，面试了在开源社区名满天下的技术天才、Linux 操作系统的缔造者李纳斯，并且将其招至麾下，一待就是六年。从某种程度上，这六年严重的影响了 Linux 操作系统前行的脚步，因为李纳斯没有足够的时间开发 Linux 了。</p><p>虽然根据 Transmeta 与李纳斯的协议，他可以继续从事 Linux 的开发，而且他确实也想这么做，比如白天为 Transmeta 工作，编写 X86 解释程序，晚上继续 Linux 的伟大事业。不过真实的情况是，晚上丫睡着了……</p><p>关于加班和睡眠，李纳斯是这么解释的：</p><blockquote><p>很多人都认为加班加点的工作才算真正的工作。我可不这么想。无论是 Transmeta 的工作还是 Linux 的工作，都不是靠牺牲宝贵的睡眠时间换来的。事实上，如果你想听真话，我要说，我更喜欢睡觉。</p></blockquote><p>总之，李纳斯第一次从互联网上消失了，很多悲观的开发者纷纷奔走相告，李纳斯这小子是不是被招安了？丫开始为商业公司干活了，Linux 作为自由软件是不是已经濒临死亡了？每当这时候李纳斯就会出来给大家打打气说，哥还在呢，只不过刚睡醒……</p><p>关于李纳斯的这段经历，曾经在硅谷工作过的一位朋友给我提供了如下文字，大意是这样的：</p><blockquote><p>每次想起李纳斯这段经历，我都要感慨万千。第一次得知李纳斯虎落硅谷的事是在2002年夏天，当地的水星报记者先是把李纳斯大吹一通，然后说他从芬兰老家搬到美国，就职于 Transmeta 已五年有余，但 H1 移民仍然停留在劳工卡初级阶段，六年期满就要打道回府了。</p></blockquote><blockquote><p>当时这份报纸的读者大概有一半人有 H1 经历，然后这一半人里的一半都知道 Linux 是啥东东，但是从未听说过 Transmeta 是何方神圣，这货居然把一代技术英雄扣在那儿为一个名不见经传的小资本家作苦力，导制全球开源事业停滞不前，真是胆大包天啊！于是很多读者跑到水星报去说，象李纳斯这样的天才愿意移民到美国，布什亲自开飞机去接都不为过，怎么可以被移民局压了五年呢balabala……</p></blockquote><p>还好，李纳斯在2003年离开了这个叫做「全美达」的公司，受聘于开放源代码开发实验室（OSDL : Open Source Development Labs, Inc），重新统领开源世界的各路英豪，全力开发 Linux 内核，Linux 再次焕发出勃勃生机，这一次，它要引领的是互联网的技术浪潮……</p><h4 id="Linus（七）——关于财富"><a href="#Linus（七）——关于财富" class="headerlink" title="Linus（七）——关于财富"></a>Linus（七）——关于财富</h4><p>李纳斯对待财富的态度就是「视金钱为粪土」，是真的粪土。</p><p>那种默然的态度让人感觉非常可怕。当一个人随便动动手挂挂名签个字就能获取上千万美金的时候，他依然和自己的妻女一家人挤在圣克拉拉一栋两层楼的公寓套房里，过着一个普通程序员的生活，同时不断改进已经遍布全球的 Linux，这是什么精神？这是毫不利己专门利人的国际主义战士的精神。</p><p>写到这我不禁想起了绿茵场上的冰王子博格坎普，当他接到几十米外的长传，用标志性的慢速停球过掉扑上来的后卫，轻扣，过掉另一个后卫，颠球，闪过最后的防守，面对守门员的时候不是大力抽射和仰天长啸，而是把球搓出一道完美的抛物线，球越过门将，缓缓落入网窝，然后博格坎普，低着头慢慢的走开，留给对手的是优雅与实用并世无双的技艺，和令人绝望的背影！</p><p>默然的感觉，懂了撒？</p><p>很多程序员创业成功或跟随创业成功之后，自以为功成身退，最早扔掉的就是代码和编译器，然后购豪宅当天使满世界贴旅游照片，你们感受一下，这个境界是完全不可同日而语的。（请勿对号入座，如有误伤，必是友军所为）</p><p>事实上李纳斯在拿到第一笔真正的财富之前，一直处于日子紧巴巴的状态。当时另两位带头大哥比尔·盖茨和史蒂夫·乔布斯早已名满天下家私万贯，同时有大量的技术人员、商人和公司通过 Linux 及其相关技术获取了巨额财富，对此，李纳斯的态度是：「和我有毛关系」，他似乎对一大群才气不高的编程人员能够享受到大笔的财富并不在意。这种情况一直持续到所有的有识之士都坐不住了：李纳斯，你再也不能这样下去了！</p><p>伦敦的一位企业家希望李纳斯在他羽翼未丰的 Linux 公司做个董事会成员，报酬是一千万美金。李纳斯说，不用。企业家惊呆了，当他喃喃自语「卧槽你特么知道一千万美金是啥概念吗」的时候，李纳斯已默默走远。</p><p>Red Hat 公司为了感谢李纳斯的卓越贡献，为他提供了一些期权，李纳斯的回复同样是，不用了，我不会给你独家的授权许可的。Red Hat 的人差点疯掉：「李爷期权您就收着吧，我们什么都不要行了吧」「唔这样啊，那就放这吧」，这就是李纳斯！</p><p>正是这笔期权让李纳斯收获了第一笔巨额财富，因为 Red Hat 1999年8月11日在纳斯达克上市了。李纳斯先是意识到自己从身无分文突然变成了拥有五十万美元的土豪，然后是一百万，五百万，李纳斯终于变得亢奋起来，原来期权也是钱啊！终于不用再为生计发愁了，对着这个事情，李纳斯的定义是：我真是最幸运的家伙！</p><p>事实上李纳斯从来没有想过 Linux 能够获得如此巨大的成功。他只是为了自己方便写了一个操作系统内核并想借此获得一点回报而已，「假如我事先知道了要做到如 Linux 这般成功需要做多少基础和琐碎工作的话，那我肯定会相当沮丧的。这意味着你首先要非常优秀，并且你所做的大部分决定都导致了正确的结果。」</p><p>任何理智的人在登山之前凝望着高耸入云的山峰和崎岖艰险的山路时，都会陷于沮丧之中。解决办法就是先迈出第一步再说，然后，但行好事，莫问前程。</p><p>Linux 不仅给李纳斯带来了名声和财富，同时给大众带去了巨大的好处。年轻一代中最聪明的程序员和黑客都在使用 Linux 的产品，正是开放的 Linux 给这些天才的程序员带去了巨大的创作热情和喜悦，他们在 Linux 平台上完成了一个又一个杰出的作品，这些技术形成的生产力，对互联网的发展起到了巨大的推动作用，直到今天。</p><h4 id="Linus（八）——巨星碰撞"><a href="#Linus（八）——巨星碰撞" class="headerlink" title="Linus（八）——巨星碰撞"></a>Linus（八）——巨星碰撞</h4><p>在 Linux 出现之前，桌面操作系统的市场基本上是由比老师和乔老师控制的，虽然乔老师控制的少了一些。Linux 出现之后，桌面操作系统的格局并没有太大变化，但是服务器端市场的变化却是翻天覆地的。原本比尔希望通过 Windows NT 和 Server 系列在服务器领域复制桌面操作系统的辉煌，从而千秋万载，一统江湖。然而，世界的发展永远是多元的，没人能通过一己之力改变历史发展的多维性，比尔·盖茨也不行。于是 Linux 出现了，并以星星之火可以燎原之势一举拿下服务器操作系统的半壁江山。</p><p>一方是商业公司和封闭的策略，另一方是自由软件和开放的协议，这场战争一开始支持率就是一边倒的，李纳斯就像对抗风车的堂·吉诃德，但是他自己不仅没有遍体鳞伤，还在没怎么亲自出场的情况下把微软这个软件风车搞得狼狈不堪，这种情况发生在现实生活中绝对是老百姓喜闻乐见的，李纳斯成了自由软件世界里的英雄和领袖，但也就此与微软结下了世仇，比尔和李纳斯许下了永世不相见的誓言。</p><p>有些加盟微软的朋友告诉李纳斯，他们曾见到他的头像被钉在了微软公司的飞镖靶心上。李纳斯对此的评价是：一定是我的大鼻子太好瞄准了。</p><p>李纳斯与另一位业界巨头苹果之间就没这么激进了，毕竟 Linux 和 OS X 师出同门，都是从老前辈 Unix 那儿毕业的，坐在一起还能唠唠家常，事实上李纳斯和乔布斯确实有过一次历史性的会面。</p><p>李纳斯来到硅谷不久，就收到了一封来自乔老师秘书的邮件，邮件中写到：「听闻小李飞刀光临硅谷，蓬荜生辉，老乔不才，重回苹果，以期振昔日之雄风，如得小李相助，必将如猛虎加之羽翼而翱翔四海，天下可得。期待会面。」（当然是意译）</p><p>李纳斯看完之后不明白乔布斯要干什么，只是觉得很厉害的样子。毕竟李纳斯还坐在外公腿上拨弄电脑键盘的时候，苹果的沃兹已经纯手动打造出苹果的第一代个人电脑 Apple I 了。李纳斯决定去见一下儿时的偶像，并了解一下苹果的新操作系统。</p><p>两代科技巨星的会面被安排在苹果总部 Infinity Loop，乔布斯带着原 Next 公司技术总监 Avie Tevanian（Mach 之父）接见了李纳斯，双方进行了友好而亲切的会谈，然后会谈的结果和某国常规会谈一样，就是没有结果。</p><p>其时乔布斯十年放逐回归苹果，举手投足已是大宗师气势，他对李纳斯说，我大苹果虽然现在看起来有点颓，不过海盗精神永存，我们已经准备好重新起航了。目前个人电脑领域仍然只有两个玩家：微软和苹果。如果 Linux 和苹果能够珠联璧合，那一切将是最好的安排，所有的开源爱好者都能够用上优雅与极客并存的 MacLinux 了。然后 Mach 之父 Avie Tevanian 向李纳斯详细介绍了整合 Mach 和 Linux 内核作为 OS X 混合内核的计划，之后庞大的 OS X 体系将构建在 Mach 和 Linux 内核的基础之上。 同时乔老师表示，基于 Mach 和 Linux 的内核系统将采用开源的方式运作，这样全世界的开源爱好者都可以为 Mac 和 Linux 开发程序。</p><p>这几乎是一个完美的双赢方案，乔老师都被自己描绘的蓝图打动了，永远年轻，永远他妈的热泪盈眶！谁能拒绝苹果公司和乔布斯如此完美的邀请呢？</p><p>李纳斯能！</p><p>乔布斯认为自己的扭曲现实力场加上苹果巨大的市场潜力一定会让李纳斯怦然心动，没想到这个芬兰小子在计算机面前待久了，水米油盐不进，任凭乔布斯口吐莲花，我自巍然不动。首先李纳斯对 Mach 就不感冒，他认为 Mach 几乎犯下了所有的设计错误，它让系统变得复杂而效率低下；其次李纳斯觉得乔布斯可能没意识到，Linux 的潜在用户要比苹果系统多；第三李纳斯乐观的认为，虽然 Linux 的目标不是占领桌面操作系统，但是显然「我们很快就能做到这一点了」。所以李纳斯当时的反应是：</p><blockquote><p>为什么我要关心这些？我为什么要对苹果公司的故事感兴趣？我不觉得苹果公司里有什么有趣的事情。我的目标也不是占领什么桌面操作系统的市场。（嗯，虽然 Linux 马上就要做到这点了，但这从来就不是我的目标）</p></blockquote><p>现在看来，李纳斯当时对 Linux 在桌面操作系统的前景过于乐观了，虽然他天纵奇才桀骜不驯，但是也无法预测到 OS X 和 iOS 在十年后引领移动开发的浪潮。不过即使知道 OS X 未来的大发展，心高气傲的李纳斯也不会接受苹果的收编，因为 Linux 一直是独立和自由的软件图腾。</p><p>无论如何，这次非正式的会谈没有达成任何实质性的效果，但是对后来的 IT 格局产生了巨大的影响。苹果不再关注 Linux，而是转向了 BSD。2001年苹果任命 FreeBSD 的发起人之一，老牌 BSD 黑客 Jordan Hubbard 为 BSD 技术经理，后升为 Unix 技术总监，负责 OS X 操作系统底层核心 Darwin 的研发，最终，Mach 与 BSD 技术整合在一起，形成了混合内核。另外，苹果开始觉得开源项目也不是那么靠谱，后续他们先后研发并开源了优秀的编译器项目 LLVM 和 Clang，一举替换了整条 GCC 编译链，为 OS X 和 iOS 的性能优化和语言特性提供了巨大的帮助。这也算是苹果对那些牛叉哄哄的开源人士的回击：看，我们也可以做开源，而且比你们做的好。</p><p>Linux 则继续在开源、独立、自由的方式下一路狂奔，虽然在桌面操作系统领域的成就乏善可陈，但是在服务器端大放异彩，目前几乎整个互联网都是运行在 Linux 及其衍生产品之上的，可以说没有 Linux，互联网不可能得到如此迅猛的发展。</p><p>十年以后，移动互联网时代来临。OS X 上长出了 iOS，Linux 上则诞生了 Android，这两个移动开发领域的双子星都有一个老祖宗，那就是 Unix。一次话不投机的会谈让 OS X 和 Linux 分道扬镳，在十几年后的今天，它们又以一种不同的方式相见了，世界永远都是多元的，可能冥冥中自有天意吧。</p><h4 id="Linus（九）——Linus-和-Git"><a href="#Linus（九）——Linus-和-Git" class="headerlink" title="Linus（九）——Linus 和 Git"></a>Linus（九）——Linus 和 Git</h4><p>很多人在完成了类似 Linux 这样宏伟的软件产品之后，基本上就止步不前了。但是李纳斯却从未停歇创新的脚步。2003年加入开放源代码开发实验室之后，李纳斯重新全职投入 Linux 内核的研发，并开始酝酿自己的另一个跨时代的产品。</p><p>2002年，Linux 内核开发团队开始采用 BitKepper 作为代码版本管理工具。BitKeeper 是一套分布式的版本管理工具，它满足了 Linux 内核开发的技术需求。但是 BitKeeper 只是暂时对 Linux 等开源软件团队免费，并不是自由软件。2005年 BitMover 公司不再免费赞助 Linux 开发团队。对此李纳斯表示非常遗憾，但遗憾之后他并没有自怨自艾伤心落泪，而是愤怒的与其他几个小伙伴花了几个星期完成了一套新的分布式代码管理工具，命名为 Git。两个月之后，Git 发布了官方版本，并在不同的项目中应用，自由软件社区给予了 Git 广泛的支持。</p><p>与 SVN 和 CVS 等软件不同的是，Git 更关注文件的整体性是否有改变，Git 更像一个文件系统，它允许开发者在本地获取各种数据，而不是随时都需要连接服务器。Git 的最大的特点就是离线分布式代码管理，速度飞快，适合管理大型项目，难以置信的非线性分支管理。</p><p>2005年 Git 发布之后，技术日臻成熟，很多大公司都开始采用 Git 管理自己的项目代码，2008年2月 Github 公司基于 Git 构建了协作式源代码托管网站 Github，目前该网站是这个星球上最大的源代码集散地，几乎所有的优秀代码都托管在 Github 上。Git 已经成为程序员使用最多的源代码管理工具！</p><p>对于 Git 的成功，李纳斯表示：</p><blockquote><p>Git的设计其实很简单，它有一个稳定而合理的数据结构。事实上，我强烈建议围绕着数据来设计代码，而不是反其道而行之，我觉得这可能就是 Git 如此成功的原因。<br>坏程序员总是担心他们的代码，而优秀的程序员则会担心数据结构和它们之间的关系。</p></blockquote><p>从 Git 诞生到今天已经有9个年头了，Git 始终没有背离其设计的初衷：高性能、简单的设计、非线性高并发分支的支持和完全的分布式。</p><p>对于李纳斯来说，Git 现在是他的主要消遣工具之一。他很喜欢在 Git 上编程的感觉，因为再也不用担心锁定问题、安全问题和网络问题，这种感觉真是太美妙了！</p><p>我们继续期待李纳斯的第三个伟大的作品！</p><h4 id="Linus（十）——生活的意义"><a href="#Linus（十）——生活的意义" class="headerlink" title="Linus（十）——生活的意义"></a>Linus（十）——生活的意义</h4><p>李纳斯认为生活意义的全部就在于：生存，社会交往和寻找乐趣。因为我们所做的一切事情，最终似乎都是为了我们自己的乐趣。而进化作为主线始终贯穿其中。</p><p>李纳斯对进化的理解是：</p><blockquote><p>你知道在整个太阳系，人类已知的最复杂的工程是什么吗？——不是Linux，不是Solaris，也不是你的汽车。是你，还有我。想想你和我都是怎么来的——不是什么超复杂的设计，没错，凭运气。除了运气，还有：</p><ul><li>通过分享「源代码」实现自由的可用性和授粉机制，生物学家把它称作DNA。</li><li>毫不手软的用户环境把我们不好的版本轻易地替换成更好的可执行版本，从而使种群更加优秀（生物学家把这叫做「适者生存」）。</li><li>大量的无方向的并行开发（试错法）。<br>我从未如此严肃过：我们人类永远都无法复制出比我们自身更复杂的个体，而自然选择却不假思索的做到了。不要低估适者生存的力量。不要错误地认为你可以做出比大量的平行试错反馈环更好的设计，那样就太抬举你的智力水平了。说实话，太阳照常升起，这和任何人的工程技巧或者编程风格都没有关系。</li></ul></blockquote><p>李纳斯一生只为寻找欢笑，但是他却取得了无数的成就和荣誉：</p><p>1997年，在芬兰赫尔辛基大学计算机科学系，李纳斯接受了他的硕士学位。两年后，他在斯德哥尔摩大学接受名誉博士学位，并在2000年在他的母校获得了同样的荣誉。</p><p>1998年，李纳斯接受了电子前哨基金会先锋奖。</p><p>2004年，李纳斯被《时代》杂志选为世界上最有影响力的人之一。</p><p>2006年，《时代》杂志欧洲版评选李纳斯为过去60年最有革命性的英雄人物之一。</p><p>2012年4月20日，托瓦兹被宣布成为两位获奖者之一，和山中伸弥共同获得当年的千禧技术奖。该奖被普遍形容为相当于在技术领域的诺贝尔奖。</p><p>2012年4月23日，李纳斯进入互联网协会（Internet Society，ISOC）的网络名人堂。</p><p>李纳斯憎恶分明，经常口不择言，比如他对 C++的评价是：C++是一门糟糕的语言。而且有一群不合格的程序员在使用C++，他们让它变得更糟糕了。他对自己的两个产品命名的解释是：我是个自大的混蛋，我所有的项目都以我的名字来命名。开始是Linux， 然后是Git（英国俚语，饭桶的意思）。</p><p>不过我最喜欢李纳斯说过的一句话是：Talk is cheap, Show me the code。他一直用自己的编程人生诠释着这句话。2006年的时候，Linux 内核代码的2%依然是李纳斯完成的，他是代码贡献最多的人之一（是年37岁）。到了2012年，他对内核的贡献主要是合并代码，编程变少了，但是他依然对是否将新代码并入到 Linux 内核具有最终决定权。</p><p>李纳斯用自己精彩的编程人生和对自由软件的热爱演绎了现代社会中一个书呆子的胜利。如果你爱一个人，就让他去编程吧；如果你恨一个人，就让他去编程吧。代码让我们欢笑，也让我们忧伤，让我们沉默，也让我们高歌。对于程序员来说，代码是这个世界上最美妙的音乐，会编程的孩子，都是好孩子！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[转载：&lt;a href=&quot;https://www.oschina.net/news/72562/linus-smell]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oschina.net/news/72562/linus-sme
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PDCA循环和SMART原则</title>
    <link href="https://blog.hitime.wiki/2018/12/10/PDCA%E5%BE%AA%E7%8E%AF%E5%92%8CSMART%E5%8E%9F%E5%88%99/"/>
    <id>https://blog.hitime.wiki/2018/12/10/PDCA循环和SMART原则/</id>
    <published>2018-12-10T15:08:50.000Z</published>
    <updated>2018-12-10T15:13:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/12/10/PDCA循环和SMART原则/PDCA_1.jpeg" alt="PDCA"><br><img src="/2018/12/10/PDCA循环和SMART原则/PDCA_2.jpeg" alt="PDCA"><br><img src="/2018/12/10/PDCA循环和SMART原则/PDCA_3.jpeg" alt="PDCA"><br><img src="/2018/12/10/PDCA循环和SMART原则/SMART_1.jpeg" alt="SMART"><br><img src="/2018/12/10/PDCA循环和SMART原则/SMART_2.jpeg" alt="SMART"><br><img src="/2018/12/10/PDCA循环和SMART原则/SMART_3.jpeg" alt="SMART"><br><img src="/2018/12/10/PDCA循环和SMART原则/SMART_4.jpeg" alt="SMART"><br><img src="/2018/12/10/PDCA循环和SMART原则/SMART_5.jpeg" alt="SMART"><br><img src="/2018/12/10/PDCA循环和SMART原则/SMART_6.jpeg" alt="SMART"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2018/12/10/PDCA循环和SMART原则/PDCA_1.jpeg&quot; alt=&quot;PDCA&quot;&gt;&lt;br&gt;&lt;img src=&quot;/2018/12/10/PDCA循环和SMART原则/PDCA_2.jpeg&quot; alt=&quot;PDCA&quot;&gt;&lt;br&gt;&lt;img sr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL索引原理及分类</title>
    <link href="https://blog.hitime.wiki/2018/12/08/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%86%E7%B1%BB/"/>
    <id>https://blog.hitime.wiki/2018/12/08/MySQL索引原理及分类/</id>
    <published>2018-12-08T13:40:21.000Z</published>
    <updated>2018-12-08T14:16:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>[转载并整理自：<a href="https://www.cnblogs.com/bypp/p/7755307.html]" target="_blank" rel="noopener">https://www.cnblogs.com/bypp/p/7755307.html]</a></p><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><h3 id="1-什么是索引？"><a href="#1-什么是索引？" class="headerlink" title="1.什么是索引？"></a>1.什么是索引？</h3><p>一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，在生产环境中，我们遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，因此对查询语句的优化显然是重中之重。说起加速查询，就不得不提到索引了。</p><h3 id="2-为什么要有索引呢？"><a href="#2-为什么要有索引呢？" class="headerlink" title="2.为什么要有索引呢？"></a>2.为什么要有索引呢？</h3><p>索引在MySQL中也叫做“键”，是存储引擎用于快速找到记录的一种数据结构。<br>索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要。<br>索引优化应该是对查询性能优化最有效的手段了，索引能够轻易将查询性能提高好几个数量级。<br>索引相当于字典的音序表，如果要查某个字，如果不使用音序表，则需要从几百页中逐页去查。</p><h2 id="二、索引原理"><a href="#二、索引原理" class="headerlink" title="二、索引原理"></a>二、索引原理</h2><h3 id="1-索引的原理"><a href="#1-索引的原理" class="headerlink" title="1.索引的原理"></a>1.索引的原理</h3><p>索引的目的在于提高查询效率，与我们查阅图书所用的目录是一个道理：先定位到章，然后定位到该章下的一个小节，然后找到页数。相似的例子还有：查字典，查火车车次，飞机航班等。<br><strong>本质都是：通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。</strong><br>数据库也是一样，但显然要复杂的多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的。而数据库实现比较复杂，一方面数据是保存在磁盘上的，另外一方面为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。</p><h3 id="2-磁盘IO与预读"><a href="#2-磁盘IO与预读" class="headerlink" title="2.磁盘IO与预读"></a>2.磁盘IO与预读</h3><p>考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，<strong>当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内。</strong>因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</p><h3 id="3-索引的数据结构"><a href="#3-索引的数据结构" class="headerlink" title="3.索引的数据结构"></a>3.索引的数据结构</h3><p>任何一种数据结构都不是凭空产生的，一定会有它的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，那就是：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，b+树应运而生。<br><img src="/2018/12/08/MySQL索引原理及分类/mysql-b+tree.png" alt="MySQL索引数据结构"><br>如上图，是一颗b+树，关于b+树的定义可以参见B+树，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p><h4 id="b-树的查找过程"><a href="#b-树的查找过程" class="headerlink" title="b+树的查找过程"></a><strong>b+树的查找过程</strong></h4><p>如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p><h4 id="b-树性质"><a href="#b-树性质" class="headerlink" title="b+树性质"></a><strong>b+树性质</strong></h4><p><strong>1.索引字段要尽量的小：</strong>通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。<br><strong>2.索引的最左匹配特性（即从左往右匹配）：</strong>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</p><h2 id="三、索引分类"><a href="#三、索引分类" class="headerlink" title="三、索引分类"></a>三、索引分类</h2><h3 id="1-索引分类"><a href="#1-索引分类" class="headerlink" title="1.索引分类"></a>1.索引分类</h3><ol><li>普通索引index:加速查找    </li><li>唯一索引<br> a. 主键索引:primary key ：加速查找+约束（不为空且唯一）<br> b. 唯一索引:unique：加速查找+约束 （唯一）</li><li>联合索引<br> a. primary key(id,name):联合主键索引<br> b. unique(id,name):联合唯一索引<br> c. index(id,name):联合普通索引</li><li>全文索引fulltext:用于搜索很长一篇文章的时候，效果最好。</li><li>空间索引spatial:了解就好，几乎不用。</li></ol><h3 id="2-索引的两大类型hash与btree"><a href="#2-索引的两大类型hash与btree" class="headerlink" title="2.索引的两大类型hash与btree"></a>2.索引的两大类型hash与btree</h3><p>hash类型的索引：查询单条快，范围查询慢<br>btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）</p><h2 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h2><p><strong>不同的存储引擎支持的索引类型也不一样</strong><br>InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引(开启配置后可以支持自适应Hash索引)；<br>MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；<br>Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引；<br>NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引；<br>Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引；   </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[转载并整理自：&lt;a href=&quot;https://www.cnblogs.com/bypp/p/7755307.html]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/bypp/p/7755307.html
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git分支管理</title>
    <link href="https://blog.hitime.wiki/2018/11/08/Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
    <id>https://blog.hitime.wiki/2018/11/08/Git分支管理/</id>
    <published>2018-11-08T13:40:21.000Z</published>
    <updated>2018-12-14T15:11:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>Git分支功能十分强大，管理方案也多种多样，对于不同的团队规模及开发方式会有不同的分支管理方案。对于我们团队我设想的分支管理方案会结合Sprint的管理方式进行设计，总体思路按照功能分支+测试环境分支方式进行管理，详细管理方式如下：</p><h2 id="阶段一：Sprint开始，工期确认及功能分支创建"><a href="#阶段一：Sprint开始，工期确认及功能分支创建" class="headerlink" title="阶段一：Sprint开始，工期确认及功能分支创建"></a>阶段一：Sprint开始，工期确认及功能分支创建</h2><p>Sprint敲定，任务及工期认领完毕，确定对应系统从master创建功能分支。功能分支命名方式：</p><blockquote><p>命名规则：<em>feature/\${Sprint截止日期}/\${功能名称}</em><br>命名示例：<em>feature/20181018/mortgageUpdate</em></p></blockquote><p>对于当前阶段，Sprint截止日期默认为功能上线日期，在开发过程中同一功能开发人员将开发完毕的功能Push到当前功能分支。</p><h2 id="阶段二：开发联调阶段"><a href="#阶段二：开发联调阶段" class="headerlink" title="阶段二：开发联调阶段"></a>阶段二：开发联调阶段</h2><p>如果功能涉及到多方联调可以选择使用Profile为local的配置文件对接对应系统的开发环境进行本地联调也可以将功能分支发布到开发环境进行开发环境联调。<br>开发环境分支默认名称为dev，开发人员将对应功能分支合并到开发分支并完成相关配置可以进行开发联调。</p><h2 id="阶段三：功能提测，合并到测试分支"><a href="#阶段三：功能提测，合并到测试分支" class="headerlink" title="阶段三：功能提测，合并到测试分支"></a>阶段三：功能提测，合并到测试分支</h2><p>测试分支命名规则和开发分支不太相同，为了能够将不同阶段的Sprint功能不冲突的提测，测试环境分为两套环境并且可以选择发布对应分支。</p><blockquote><p>命名规则：<em>test/${Sprint截止日期}</em><br>命名示例：<em>test/20181018</em></p></blockquote><p>需要注意的是，在测试阶段的分支不再带功能名称，因为此刻同一Sprint阶段的不同功能会汇集到此测试分支进行全覆盖测试。QA已经提供两套测试环境可以并行两个Sprint版本开发及测试。<br>另外需要注意的是测试分支从功能分支直接合并而来不再经过dev分支。</p><h2 id="阶段四：Sprint结束，功能上线"><a href="#阶段四：Sprint结束，功能上线" class="headerlink" title="阶段四：Sprint结束，功能上线"></a>阶段四：Sprint结束，功能上线</h2><p>功能上线前，将Sprint对应的测试分支合并到master上，一旦出现冲突使用<strong>git merge —abort</strong>终止合并以保证master分支干净然后将master分支合并到当前测试分支并解决冲突后再合并到master。<br>合并完成后给master打上tag方便下次发布错误后使用该tag进行回滚，添加tag命令：<strong>git tag -a v1.4 -m ’my version 1.4‘</strong></p><h2 id="异常情况：线上出现问题使用热修复分支"><a href="#异常情况：线上出现问题使用热修复分支" class="headerlink" title="异常情况：线上出现问题使用热修复分支"></a>异常情况：线上出现问题使用热修复分支</h2><p>线上功能出现问题需要紧急修复，此时从master迁出热修复分支，命名方式如下：</p><blockquote><p>命名规则：<em>${修复日期}_hotfix</em><br>命名示例：<em>20181018_hotfix</em></p></blockquote><p>该分支为热修复分支为了尽快修复线上问题经过验证后不需要再合并到测试分支直接合并到master分支做紧急发布。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Git分支功能十分强大，管理方案也多种多样，对于不同的团队规模及开发方式会有不同的分支管理方案。对于我们团队我设想的分支管理方案会结合Sprint的管理方式进行设计，总体思路按照功能分支+测试环境分支方式进行管理，详细管理方式如下：&lt;/p&gt;
&lt;h2 id=&quot;阶段一：Spri
      
    
    </summary>
    
    
  </entry>
  
</feed>
